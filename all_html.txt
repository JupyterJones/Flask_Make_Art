
#!/home/jack/Desktop/Flask_Make_Art/flask_env/bin/python
import os
import random
import glob
from flask import Flask, request, render_template, request, redirect, url_for, send_from_directory, send_file, flash, jsonify
from flask import render_template_string
from PIL import Image, ImageOps, ImageDraw, ImageFont, ImageFilter
from moviepy.editor import ImageClip, VideoClip, clips_array, concatenate_videoclips, CompositeVideoClip, ColorClip, VideoFileClip,AudioFileClip
from matplotlib import pyplot as plt
from skimage import future, data, segmentation, filters, color, io
from skimage.future import graph
import datetime
import inspect
import time
import datetime
import inspect
import subprocess
import shutil
from werkzeug.utils import secure_filename
import numpy as np
import yt_dlp
import dlib
import cv2
from PIL import Image, ImageFilter, ImageOps, ImageDraw, ImageFont
import glob
import subprocess
import string
import uuid
from skimage.io import imread, imsave
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'static/archived-images'
#app.config['UPLOAD_FOLDER']= 'static/archived-resources'
app.config['MASK_FOLDER'] = 'static/archived-masks'
app.config['STORE_FOLDER'] = 'static/archived-store'
#app.config['STORE_FOLDER'] = 'static/KLING'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Limit upload size to 16MB
# Directory to save downloaded videos and extracted images
DOWNLOAD_FOLDER = 'static/downloads'
ARCHIVED_IMAGES_FOLDER = 'static/archived-images'
app.config['DOWNLOAD_FOLDER'] = DOWNLOAD_FOLDER
app.config['ARCHIVED_IMAGES_FOLDER'] = ARCHIVED_IMAGES_FOLDER

# Ensure the directories exist
os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)
os.makedirs(ARCHIVED_IMAGES_FOLDER, exist_ok=True)
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}
# Configurations
app.config['TEMP_FOLDER'] = 'static/temp/'
app.config['FONT_FOLDER'] = 'static/fonts/'
app.config['PUBLISH_FOLDER'] = 'static/archived-store/'

currentDir = os.getcwd()


#@app.route('/convert', methods=['POST'])
def convert_images():
    # Directory containing the JPG images
    image_directory = 'static/archived-store'  # Adjust this path as needed
    
    logit(f"Starting conversion in directory: {image_directory}")
    
    # Check if directory exists
    if not os.path.isdir(image_directory):
        logit(f"Directory does not exist: {image_directory}")
        return redirect(url_for('index'))
    
    # Loop through all files in the directory
    for filename in os.listdir(image_directory):
        if filename.lower().endswith('.jpg'):
            # Construct full file paths
            jpg_path = os.path.join(image_directory, filename)
            png_filename = os.path.splitext(filename)[0] + '.png'
            png_path = os.path.join(image_directory, png_filename)
            
            try:
                logit(f"Converting {jpg_path} to {png_path}")
                
                # Open the JPG image and convert it to PNG
                with Image.open(jpg_path) as img:
                    img = img.convert('RGBA')  # Ensure image has alpha channel if needed
                    img.save(png_path, format='PNG')
                
                logit(f"Successfully converted {jpg_path} to {png_path}")
                
                # Remove the original JPG file
                os.remove(jpg_path)
                logit(f"Removed original file: {jpg_path}")
                
            except Exception as e:
                logit(f"Failed to convert {jpg_path}. Error: {e}")
    
    logit("Image conversion process completed.")
    return redirect(url_for('index'))
# Ensure the static/masks directory exists
if not os.path.exists('static/masks'):
    os.makedirs('static/masks')

@app.route('/mk_mask')
def mk_mask():
    masks=glob.glob('static/archived-images/mask*.jpg')
    # list by date, last image first
    masks = sorted(masks, key=os.path.getmtime, reverse=True)
    filenames = [os.path.basename(mask) for mask in masks]
    mask_data = zip(masks, filenames)
    return render_template('mk_mask.html',mask_data=mask_data)


@app.route('/create_mask', methods=['POST'])
def create_mask():
    # Get input values from the form
    x = int(request.form.get('x', 0))
    y = int(request.form.get('y', 0))
    size = int(request.form.get('size', 50))+20
    
    feather = int(request.form.get('feather', 20))
    aspect = int(request.form.get('aspect', 0))
    
    # Calculate width and height based on aspect
    if aspect > 0:
        width = size
        height = size + aspect
    elif aspect < 0:
        width = size - abs(aspect)
        height = size
    else:
        width, height = size, size

    # Create a black background image
    background = Image.new('RGBA', (512, 768), (0, 0, 0, 255))
    
    # Create a white circle with the specified size and aspect ratio
    circle = Image.new('RGBA', (width, height), (0, 0, 0, 0))
    draw = ImageDraw.Draw(circle)
    draw.ellipse((0, 0, width, height), fill=(255, 255, 255, 255))

    # Apply feathering
    circle = circle.filter(ImageFilter.GaussianBlur(feather))

    # Calculate position to paste the circle (centered by default)
    paste_position = (256 + x - width // 2, 384 + y - height // 2)
    background.paste(circle, paste_position, circle)
    background = background.convert('RGB')
    
    background = background.filter(ImageFilter.GaussianBlur(30))
    # Save the result
    mask_path = f'static/archived-images/mask_{x}_{y}_{size}_{feather}_{aspect}.jpg'
    background.save(mask_path)
    masks=glob.glob('static/archived-images/mask*.jpg')
    # list by date, last image first
    masks = sorted(masks, key=os.path.getmtime, reverse=True)
    logit(f"Mask saved at: {mask_path}")
    filenames = [os.path.basename(mask) for mask in masks]
    mask_data = zip(masks, filenames)
    return render_template('mk_mask.html', mask_path=mask_path, mask_data=mask_data)



    #return send_file(mask_path, as_attachment=True)
def save_text_to_file(filename, text):
    try:
        with open(os.path.join(TEXT_FILES_DIR, filename), "w") as file:
            file.write(text)
        logit(f"File '{filename}' saved successfully.")
    except Exception as e:
        logit(f"An error occurred while saving file '{filename}': {e}")

# Route for the form
@app.route('/add_text', methods=['GET', 'POST'])
def add_text():
    # Get the list of images in the PUBLISH_FOLDER
    images = os.listdir(app.config['PUBLISH_FOLDER'])
    
    if request.method == 'POST':
        image_file = request.form['image_file']
        text = request.form['text']
        position = (int(request.form['x_position']), int(request.form['y_position']))
        font_size = int(request.form['font_size'])
        color = request.form['color']
        font_path = os.path.join(app.config['FONT_FOLDER'], 'MerriweatherSans-Bold.ttf')
        font = ImageFont.truetype(font_path, font_size)

        logit(f"Processing image: {image_file}")
        logit(f"Text to add: '{text}' at position {position}, font size: {font_size}, color: {color}")

        # Open the image
        image_path = os.path.join(app.config['PUBLISH_FOLDER'], image_file)
        image = Image.open(image_path)

        # Draw the text on the image
        draw = ImageDraw.Draw(image)
        draw.text(position, text, font=font, fill=color)

        # Save the temporary image for preview
        temp_image_path = os.path.join(app.config['TEMP_FOLDER'], 'temp-image.png')
        image.save(temp_image_path)

        return render_template('add_text.html', images=images, selected_image=image_file, temp_image='temp-image.png', text=text, position=position, font_size=font_size, color=color)
    
    return render_template('add_text.html', images=images)


# Route to save the final image
@app.route('/save_image', methods=['POST'])
def save_image():
    image_file = request.form['image_file']
    final_text = request.form['final_text']
    position = eval(request.form['final_position'])  # Convert string back to tuple
    font_size = int(request.form['final_font_size'])
    color = request.form['final_color']
    font_path = os.path.join(app.config['FONT_FOLDER'], 'MerriweatherSans-Bold.ttf')
    font = ImageFont.truetype(font_path, font_size)

    # Open the image again
    image_path = os.path.join(app.config['PUBLISH_FOLDER'], image_file)
    image = Image.open(image_path)

    # Draw the final text on the image
    draw = ImageDraw.Draw(image)
    draw.text(position, final_text, font=font, fill=color)

    # Save the image with a unique UUID
    unique_filename = f"{uuid.uuid4()}.png"
    final_image_path = os.path.join(app.config['PUBLISH_FOLDER'], unique_filename)
    image.save(final_image_path)

    logit(f"Saved final image as: {unique_filename}")

    return redirect(url_for('add_text'))

if not os.path.exists(app.config['UPLOAD_FOLDER']):
    os.makedirs(app.config['UPLOAD_FOLDER'])

if not os.path.exists(app.config['MASK_FOLDER']):
    os.makedirs(app.config['MASK_FOLDER'])

if not os.path.exists(app.config['STORE_FOLDER']):
    os.makedirs(app.config['STORE_FOLDER'])

# Logging function
def logit(message):
    try:
        # Get the current timestamp
        timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y_%H-%M-%S')
        print(f"timestr: {timestr}")

        # Get the caller's frame information
        caller_frame = inspect.stack()[1]
        filename = caller_frame.filename
        lineno = caller_frame.lineno

        # Convert message to string if it's a list
        if isinstance(message, list):
            message_str = ' '.join(map(str, message))
        else:
            message_str = str(message)

        # Construct the log message with filename and line number
        log_message = f"{timestr} - File: {filename}, Line: {lineno}: {message_str}\n"

        # Open the log file in append mode
        with open("static/app_log.txt", "a") as file:
            # Write the log message to the file
            file.write(log_message)

            # Print the log message to the console
            print(log_message)

    except Exception as e:
        # If an exception occurs during logging, print an error message
        print(f"Error occurred while logging: {e}")

logit("App started")
def readlog():
    log_file_path = 'static/app_log.txt'    
    with open(log_file_path, "r") as Input:
        logdata = Input.read()
    # print last entry
    logdata = logdata.split("\n")
    return logdata

logdata = readlog()
logit("This is a DEBUG message for mylog.py" + str(logdata))

@app.route('/view_log', methods=['GET', 'POST'])
def view_log():
    data = readlog()
    return render_template('view_log.html', data=data)

def get_image_paths():
    image_paths = []
    for ext in ['png', 'jpg', 'jpeg']:
        image_paths.extend(glob.glob(os.path.join(app.config['UPLOAD_FOLDER'], f'*.{ext}')))
    image_paths = sorted(image_paths, key=os.path.getmtime, reverse=True)
    logit(f"Image paths: {image_paths}")
    return image_paths

def stored_image_paths():
    image_paths = []
    for ext in ['png', 'jpg', 'jpeg']:
        image_paths.extend(glob.glob(os.path.join(app.config['STORE_FOLDER'], f'*.{ext}')))
    image_paths = sorted(image_paths, key=os.path.getmtime, reverse=True)
    logit(f"Image paths: {image_paths}")
    return image_paths

'''@app.route('/')
def index():
    image_paths = stored_image_paths()
    return render_template('index_exp.html', image_paths=image_paths)
'''
@app.route('/')
def index():
    image_paths = stored_image_paths()
    return render_template('mk_videos.html', image_paths=image_paths)
def load_images(image_directory):
    image_paths = []
    for ext in ['png', 'jpg', 'jpeg']:
        image_paths.extend(glob.glob(os.path.join(image_directory, f'*.{ext}')))
    #random.shuffle(image_paths)
    image_paths = sorted(image_paths, key=os.path.getmtime, reverse=True)
    return image_paths[:3]

def convert_to_grayscale(image_path):
    image = Image.open(image_path).convert('L')
    mask_path = os.path.join(app.config['MASK_FOLDER'], 'greyscale_mask.png')
    image.save(mask_path)
    #copy to upload folder
    shutil.copy(mask_path, app.config['UPLOAD_FOLDER'])
    return mask_path

def convert_to_binary(image_path):
    # Convert image to grayscale
    image = Image.open(image_path).convert('L')
    
    # Calculate the mean pixel value to use as the threshold
    np_image = np.array(image)
    threshold = np.mean(np_image)
    
    # Convert image to binary based on the mean threshold
    binary_image = image.point(lambda p: 255 if p > threshold else 0)
    
    # Save the binary mask
    mask_path = os.path.join(app.config['MASK_FOLDER'], 'binary_mask.png')
    binary_image.save(mask_path)
    
    # Invert the binary mask
    inverted_image = binary_image.point(lambda p: 255 - p)
    
    # Save the inverted binary mask
    inverted_mask_path = os.path.join(app.config['MASK_FOLDER'], 'inverted_binary_mask.png')
    inverted_image.save(inverted_mask_path)
    
    # Copy both images to the upload folder
    shutil.copy(mask_path, app.config['UPLOAD_FOLDER'])
    shutil.copy(inverted_mask_path, app.config['UPLOAD_FOLDER'])
    
    return mask_path, inverted_mask_path

def resize_images_to_base(base_image, images):
    base_size = base_image.size
    logit(f"Base size: {base_size}")
    resized_images = [base_image]
    for img in images[1:]:
        resized_images.append(img.resize(base_size, resample=Image.Resampling.LANCZOS))
    return resized_images

@app.route('/get_images', methods=['POST','GET'])
def get_images():
    image_directory = app.config['UPLOAD_FOLDER']
    logit(f"Image directory: {image_directory}")
    image_paths = load_images(image_directory)
    logit(f"Loaded images: {image_paths}")
    return render_template('display_images_exp.html', image_paths=image_paths, mask_path=None, opacity=0.5)

@app.route('/play_mp3', methods=['GET', 'POST'])
def play_mp3():
    music = 'static/audio/narration.mp3'
    return render_template('play_mp3.html', music=music)
@app.route('/edit_mask', methods=['POST'])
def edit_mask():
    image_paths = request.form.getlist('image_paths')
    mask_path = request.form.get('mask_path')
    opacity = float(request.form.get('opacity', 0.5))
    return render_template('display_images_exp.html', image_paths=image_paths, mask_path=mask_path, opacity=opacity)

@app.route('/store_result', methods=['POST'])
def store_result():
    result_image_path = request.form.get('result_image')
    unique_id = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    store_path = os.path.join(app.config['STORE_FOLDER'], f'result_{unique_id}.png')
    
    # Correct the path for the result image
    result_image_path = result_image_path.replace('/static/', 'static/')
    
    # Save the result image to the store folder
    image = Image.open(result_image_path)
    image.save(store_path)
    return redirect(url_for('index'))

@app.route('/refresh-images')
def refresh_images():
    try:
        # Run the script using subprocess
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'refresh_images.py'], check=True)
        return redirect(url_for('index'))
    except subprocess.CalledProcessError as e:
        return f"An error occurred: {e}'"

@app.route('/refresh-video')
def refresh_video():
    try:
        convert_images()    
        createvideo()
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'refresh_video.py'], check=True)
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'Best_FlipBook'], check=True)
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'diagonal_transition'], check=True)
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'blendem'], check=True)
        subprocess.run(['/bin/bash', 'slide'], check=True)         
        subprocess.run(['/bin/bash', 'zoomX4'], check=True) 
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'vertical_scroll'], check=True)
        
        video_path = 'static/temp_exp/diagonal1.mp4'
        add_title(video_path, hex_color="#A52A2A")
        
        subprocess.run(['/home/jack/miniconda3/envs/cloned_base/bin/python', 'joinvid'], check=True)

        return redirect(url_for('create_video'))
    
    except subprocess.CalledProcessError as e:
        return f"An error occurred: {e}"

@app.route('/display_resources', methods=['POST', 'GET'])
def display_resources():
    # Get all image paths in the archived resources folder for jpg and png
    image_paths = glob.glob('static/archived_resources/*.jpg')
    image_paths.extend(glob.glob('static/archived_resources/*.png'))
    # List by date, last image first
    image_paths = sorted(image_paths, key=os.path.getmtime, reverse=True)
    
    # Debugging: Print the paths to verify
    logit(image_paths)
    
    return render_template('display_resources_exp.html', image_paths=image_paths)

@app.route('/copy_images', methods=['GET', 'POST'])
def copy_images():
    size_and_format_images()
    if request.method == 'POST':
        selected_images = request.form.getlist('selected_images')
        logit(f"Selected images: {selected_images}")
        
        # Copy the selected images to the store folder
        for image_path in selected_images:
            logit(f"Copying image: {image_path}")
            logit(f"Destination: {app.config['STORE_FOLDER']}")
            logit("----------------------")
            
            shutil.copy(image_path, app.config['STORE_FOLDER'])
        
        # Redirect to a page where you can view the stored images
        return redirect(url_for('clean_storage'))
    
@app.route('/select_images', methods=['GET', 'POST'])
def select_images():
    if request.method == 'POST':
        top_image = request.form.get('top_image')
        mask_image = request.form.get('mask_image')
        bottom_image = request.form.get('bottom_image')

        if not top_image or not mask_image or not bottom_image:
            return "Please select one top image, one mask image, and one bottom image."

        # Redirect to the blend_images route with the selected images
        return redirect(url_for('blend_images', top=top_image, mask=mask_image, bottom=bottom_image))

    image_paths = get_image_paths()
    return render_template('select_images.html', image_paths=image_paths)

@app.route('/blend_images', methods=['POST', 'GET'])
def blend_images():
    # Retrieve selected images from the form
    top_image = request.form.get('top_image')
    mask_image = request.form.get('mask_image')
    bottom_image = request.form.get('bottom_image')
    opacity = float(request.form.get('opacity', 0.5))

    # Check if all required images are provided
    if not all([top_image, mask_image, bottom_image]):
        return "Please select one top image, one mask image, and one bottom image."

    # Process images
    image_paths = [top_image, mask_image, bottom_image]
    result_path = blend_images_with_grayscale_mask(image_paths, mask_image, opacity)
    mask_image ="static/masks/mask.png"
    return redirect(url_for('index'))#, image_paths=image_paths, mask_path=mask_image, opacity=opacity))
#render_template('blend_result_exp.html', result_image=result_path, image_paths=image_paths, mask_image=mask_image, opacity=opacity)

def blend_images_with_grayscale_mask(image_paths, mask_path, opacity):
    if len(image_paths) != 3:
        logit(f"Error: Expected exactly 3 image paths, got {len(image_paths)}")
        return None
    base_image_path, mask_image_path, top_image_path = image_paths
    logit(f"Base image path: {base_image_path}")
    logit(f"Mask image path: {mask_image_path}")
    logit(f"Top image path: {top_image_path}")

    base_image = Image.open(base_image_path)
    mask_image = Image.open(mask_path).convert('L')
    top_image = Image.open(top_image_path)
    base_image = base_image.resize((512,768), Image.LANCZOS)
    top_image = top_image.resize((512,768), Image.LANCZOS)
    mask_image = mask_image.resize((512,768), Image.LANCZOS)
    #base_image, top_image = resize_images_to_base(base_image, [base_image, top_image])[0], resize_images_to_base(base_image, [base_image, top_image])[1]
    blended_image = Image.composite(top_image, base_image, mask_image)

    unique_id = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    result_path = os.path.join(app.config['STORE_FOLDER'], f'result_{unique_id}.png')
    blended_image.save(result_path)
    logit(f"Blended image saved at: {result_path}")

    return result_path

@app.route('/select_mask_image', methods=['POST', 'GET'])
def select_mask_image():
    if request.method == 'POST':
        selected_image = request.form.get('selected_image')
        if not selected_image:
            return "Please select an image for masking."
        return render_template('choose_mask.html', selected_image=selected_image)
    
    #get_image_paths = lambda: [os.path.join(app.config['MASK_FOLDER'], f) for f in os.listdir(app.config['MASK_FOLDER'])]
    image_paths = get_image_paths()
    return render_template('select_mask_image.html', image_paths=image_paths)

#get_image_paths = lambda: [os.path.join(app.config['MASK_FOLDER'], f) for f in os.listdir(app.config['MASK_FOLDER'])]

@app.route('/choose_mask', methods=['POST'])
def choose_mask():
    selected_image = request.form.get('selected_image')
    mask_type = request.form.get('mask_type')

    if not selected_image:
        return "Please select an image for masking."
    
    if mask_type == 'grayscale':
        mask_path = convert_to_grayscale(selected_image)
    elif mask_type == 'binary':
        mask_path = convert_to_binary(selected_image)
    else:
        return "Invalid mask type selected."
    #redirect to select
    return redirect(url_for('select_images'))
#render_template('select_images.html', image_paths=[selected_image], mask_path=mask_path, opacity=0.5)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/index_upload')
def index_upload():
    logit("Rendering upload form.")
    return render_template('index_upload.html')
'''
@app.route('/upload', methods=['POST', 'GET'])
def upload_file():
    # Check if the post request has the file part
    if 'file' not in request.files:
        flash('No file part')
        
        return redirect(request.url)

    file = request.files['file']
    logit(f"XXXXXXXX {file}")

    # If user does not select file, browser also submits an empty part without filename
    if file.filename == '':
        flash('No selected file')
        logit("No file selected.")
        return redirect(request.url)

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(save_path)
        logit(f"File saved to {save_path}.")
        return redirect(url_for('uploaded_file', filename=filename))
    else:
        flash('File type not allowed')
        logit("File type not allowed.")
        return redirect(request.url)

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    # You can create a route to handle what happens after a file is uploaded successfully
    logit(f"File uploaded: {filename}.")
    return redirect(url_for('index'))
'''
def extract_random_frames(video_path, num_frames=25):
    try:
        video = VideoFileClip(video_path)
        duration = video.duration
        timestamps = sorted([random.uniform(0, duration) for _ in range(num_frames)])
        saved_images = []
        
        for i, timestamp in enumerate(timestamps):
            frame = video.get_frame(timestamp)
            img = Image.fromarray(frame)
            image_filename = f"frame_{i+1}.jpg"
            image_path = os.path.join(app.config['ARCHIVED_IMAGES_FOLDER'], image_filename)
            img.save(image_path)
            saved_images.append(image_filename)
        
        return saved_images
    except Exception as e:
        logit(f"Error extracting frames: {e}")
        raise

@app.route('/get_video_images', methods=['GET', 'POST'])
def get_video_images():
    if request.method == 'POST':
        url = request.form['url']
        if url:
            try:
                # Download the YouTube video
                video_path = download_youtube_video(url)
                
                # Extract 25 random frames
                images = extract_random_frames(video_path)
                
                # Redirect to display the images
                return redirect(url_for('display_images'))
            except Exception as e:
                logit(f"Error in /get_images: {e}")
                return str(e)
    
    return render_template('get_images.html')

@app.route('/images')
def display_images():
    try:
        images = os.listdir(app.config['ARCHIVED_IMAGES_FOLDER'])
        images = [os.path.join(app.config['ARCHIVED_IMAGES_FOLDER'], img) for img in images]
        return render_template('YouTube_gallery.html', images=images)
    except Exception as e:
        logit(f"Error in /images: {e}")
        return str(e)

def download_youtube_video(url):
    try:
        # Set the download options
        ydl_opts = {
            'outtmpl': os.path.join(app.config['DOWNLOAD_FOLDER'], '%(title)s.%(ext)s'),
            'format': 'mp4',  # Best format available
            'noplaylist': True
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Extract video information and download the video
            info_dict = ydl.extract_info(url, download=True)
            video_title = info_dict.get('title')
            
            # Sanitize and format the filename to remove spaces and special characters
            sanitized_title = secure_filename(video_title)
            sanitized_title = sanitized_title.replace(" ", "_")
            download_path = os.path.join(app.config['DOWNLOAD_FOLDER'], f"{sanitized_title}.mp4")
            static_video_path = os.path.join('static', 'temp.mp4')

            # Find the downloaded file
            for root, dirs, files in os.walk(app.config['DOWNLOAD_FOLDER']):
                for file in files:
                    if file.endswith('.mp4'):
                        actual_downloaded_file = os.path.join(root, file)
                        break
                else:
                    continue
                break

            # Check if the video was downloaded correctly
            if os.path.exists(actual_downloaded_file):
                # Move the downloaded video to the static/temp.mp4 path
                shutil.move(actual_downloaded_file, static_video_path)
                logit(f"Video downloaded and moved to: {static_video_path}")
            else:
                logit(f"Downloaded file does not exist: {actual_downloaded_file}")
                raise FileNotFoundError(f"File not found: {actual_downloaded_file}")

            return static_video_path

    except Exception as e:
        logit(f"Error downloading video: {e}")
        raise
def create_feathered_image(foreground_path, output_path):
    # Load the foreground image
    foreground = cv2.imread(foreground_path)
    height, width = foreground.shape[:2]

    # Initialize dlib's face detector
    detector = dlib.get_frontal_face_detector()
    gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)
    faces = detector(gray_foreground)

    # Create an alpha channel and a binary mask
    alpha_channel = np.zeros((height, width), dtype=np.uint8)

    if len(faces) == 0:
        print("No face detected in the image. Using the entire image with no feathering.")
        # Use the entire image with a full alpha channel
        alpha_channel = np.full((height, width), 255, dtype=np.uint8)
    else:
        for face in faces:
            x, y, w, h = face.left(), face.top(), face.width(), face.height()
            center = (x + w // 2, y + h // 2)
            radius = max(w, h) // 2
            cv2.circle(alpha_channel, center, radius, 255, -1)

        # Feather the edges of the mask
        alpha_channel = cv2.GaussianBlur(alpha_channel, (101, 101), 0)

    # Add the alpha channel to the foreground image
    foreground_rgba = np.dstack((foreground, alpha_channel))

    # Save the result as a PNG file with transparency
    cv2.imwrite(output_path, foreground_rgba)

    print(f"Feathered image saved to: {output_path}")

    return output_path

def overlay_feathered_on_background(foreground_path, background_path, output_path):
    # Load the feathered image and background image
    foreground = cv2.imread(foreground_path, cv2.IMREAD_UNCHANGED)  # Load with alpha channel
    background = cv2.imread(background_path)

    # Resize and crop both images to 512x768
    foreground = resize_and_crop(foreground)
    background = resize_and_crop(background)

    # Extract the alpha channel from the foreground image
    alpha_channel = foreground[:, :, 3] / 255.0
    foreground_rgb = foreground[:, :, :3]

    # Ensure background has 4 channels
    background_rgba = cv2.cvtColor(background, cv2.COLOR_BGR2BGRA)
    background_alpha = background_rgba[:, :, 3] / 255.0

    # Validate dimensions
    if foreground_rgb.shape[:2] != background_rgba.shape[:2]:
        raise ValueError(f"Foreground and background dimensions do not match: {foreground_rgb.shape[:2]} vs {background_rgba.shape[:2]}")

    # Blend the images
    for i in range(3):  # For each color channel
        background_rgba[:, :, i] = (foreground_rgb[:, :, i] * alpha_channel + background_rgba[:, :, i] * (1 - alpha_channel)).astype(np.uint8)

    # Save the result
    cv2.imwrite(output_path, background_rgba)

    print(f"Composite image saved to: {output_path}")

    im = Image.open(output_path).convert('RGB')
    im.save(output_path[:-3] + 'jpg', quality=95)
    return output_path

def resize_and_crop(image, target_width=512, target_height=768):
    # Resize the image to fit the target dimensions while maintaining the aspect ratio
    height, width = image.shape[:2]
    aspect_ratio = width / height
    target_aspect_ratio = target_width / target_height

    if aspect_ratio > target_aspect_ratio:
        new_width = target_width
        new_height = int(new_width / aspect_ratio)
    else:
        new_height = target_height
        new_width = int(new_height * aspect_ratio)

    resized_image = cv2.resize(image, (new_width, new_height))

    # Ensure the resized image is at least the target dimensions
    if resized_image.shape[0] < target_height or resized_image.shape[1] < target_width:
        resized_image = cv2.resize(image, (target_width, target_height))

    # Crop the resized image to the target dimensions
    crop_x = (resized_image.shape[1] - target_width) // 2
    crop_y = (resized_image.shape[0] - target_height) // 2
    cropped_image = resized_image[crop_y:crop_y + target_height, crop_x:crop_x + target_width]

    return cropped_image

@app.route('/face_detect', methods=['POST', 'GET'])
def face_detect():
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            flash('No file part')
            logit("No file part in request.")
            return redirect(request.url)
        file = request.files['file']
        # If user does not select file, browser also submits an empty part without filename
        if file.filename == '':
            flash('No selected file')
            logit("No file selected.")
            return redirect(request.url)

        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(save_path)
            logit(f"File saved to {save_path}.")

            # Create a feathered PNG image from the detected face
            feathered_image_path = create_feathered_image(save_path, 'static/archived-images/feathered_face.png')

            # Overlay the feathered image on the background
            background_image_path = random.choice(glob.glob("static/archived-images/*.jpg"))
            output_composite_path = overlay_feathered_on_background(feathered_image_path, background_image_path, 'static/archived-images/composite_image.png')

            return render_template('face_detect.html', feathered_image=feathered_image_path, composite_image=output_composite_path)

    return render_template('face_detect.html')

@app.route('/about')#, methods=['POST', 'GET'])
def about():
    return render_template('application_overview.html')
def resize_image(image_path):
    # Open the image
    image = Image.open(image_path)
    # Resize the image
    resized_image = image.resize((512, 768), Image.LANCZOS)
    # Save the resized image
    resized_image.save(image_path)
    print(f"Resized image saved at: {image_path}")
    
@app.route('/resize_all')#, methods=['POST', 'GET'])
def resize_all():
    # Resize all images in the upload folder
    image_paths = glob.glob(os.path.join(app.config['UPLOAD_FOLDER'], '*.jpg'))
    logit(f"Image paths: {image_paths}")
    for image_path in image_paths:
        logit(f"Resizing image: {image_path}")
        resize_image(image_path)
    return redirect(url_for('index'))

import os
from datetime import datetime

@app.route('/upload_image', methods=['GET', 'POST'])
def upload_image():
    if request.method == 'POST':
        image_file = request.files['image']
        if image_file:
            filename = image_file.filename
            logit(f"Uploading image: {filename}")
            image_path = os.path.join('static', filename)  # Ensure only one 'static/' prefix
            image_file.save(image_path)
            return render_template('confirm_image.html', image_path=filename)  # Pass only the filename
    return render_template('upload_image.html')

@app.route('/torn_edge', methods=['POST'])
def create_torn_edge_effect():
    filename = request.form.get('image_path')
    image_path = os.path.join('static', filename)
    timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
    output_filename = f"result_{timestamp}.png"
    output_path = os.path.join('static', 'archived-store', output_filename)

    logit(f"Loading image: {image_path}")
    image = Image.open(image_path).convert("RGBA")

    width, height = image.size
    logit(f"Image size: {width}x{height}")

    # Create a mask with the same size as the image
    mask = Image.new("L", (width, height), 255)
    draw = ImageDraw.Draw(mask)

    # Create a random torn edge effect for all edges
    np.random.seed(0)
    torn_edge_top = np.random.normal(0, 60, width)
    torn_edge_bottom = np.random.normal(0, 60, width)
    torn_edge_left = np.random.normal(0, 60, height)
    torn_edge_right = np.random.normal(0, 60, height)

    torn_edge_top = np.clip(torn_edge_top, -100, 100)
    torn_edge_bottom = np.clip(torn_edge_bottom, -100, 100)
    torn_edge_left = np.clip(torn_edge_left, -100, 100)
    torn_edge_right = np.clip(torn_edge_right, -100, 100)

    # Apply torn edges to the top and bottom
    for x in range(width):
        draw.line((x, 0, x, int(torn_edge_top[x])), fill=0)
        draw.line((x, height, x, height - int(torn_edge_bottom[x])), fill=0)

    # Apply torn edges to the left and right
    for y in range(height):
        draw.line((0, y, int(torn_edge_left[y]), y), fill=0)
        draw.line((width, y, width - int(torn_edge_right[y]), y), fill=0)

    # Apply Gaussian blur to smooth the edges
    logit("Applying Gaussian blur to the mask")
    mask = mask.filter(ImageFilter.GaussianBlur(2))

    logit("Applying mask to the image")
    result = Image.composite(image, Image.new("RGBA", image.size, (255, 255, 255, 0)), mask)

    logit(f"Saving the result image: {output_path}")
    result.save(output_path, "PNG")
    #copy to upload folder
    shutil.copy(output_path, app.config['UPLOAD_FOLDER'])
    return render_template('torn_edge.html', original_image=filename, torn_image=os.path.join('archived-store', output_filename))

#!/home/jack/miniconda3/envs/cloned_base/bin/python
import io
import os
import base64
from flask import Flask, render_template, request, redirect, url_for, flash, send_file
from flask import send_from_directory, jsonify
import sqlite3
import datetime
from werkzeug.utils import secure_filename
import glob
import json
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
import random
import shutil
import yt_dlp
SCAN_DATA_FILE = 'local_scan_data.json'
IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png']
STATIC_IMAGE_DIR = 'static/local_images'
STATIC_IMAGE_DIR = 'static/local_images'
if not os.path.exists(STATIC_IMAGE_DIR):
    os.makedirs(STATIC_IMAGE_DIR)
STATIC_GALLERY_DATA_FILE = 'local_static_gallery_data.json'

app.static_folder = 'static'  # Set the static folder to 'static'
app.config['SECRET_KEY'] = 'your_secret_key'
app.config['VUPLOAD_FOLDER'] = 'static/videos'
app.config['ALLOWED_EXTENSIONS'] = {'mp4'}
app.config['DATABASE'] = 'static/blog3.db'
DATABASE = app.config['DATABASE']
app.config['DATABASEF'] = 'static/functions.db'
DATABASEF = app.config['DATABASEF']

@app.route('/favicon.ico')
def favicon():
    # Logging for debug purposes
    app.logger.info("Serving favicon")
    return send_from_directory(
        directory=os.path.join(app.root_path, 'static'),
        path='favicon.ico',
        mimetype='image/vnd.microsoft.icon'
    )

def logit(argvs):
    argv = argvs   
    log_file = "app_log.txt"  # Path to your log file
    timestamp = datetime.datetime.now().strftime("%A_%b-%d-%Y_%H-%M-%S")
    with open(log_file, "a") as log:
        log.write(f"{timestamp}: {argv}\n")

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

@app.route('/upload_video/<int:post_id>', methods=['POST'])
def upload_video(post_id):
    if 'videoFile' not in request.files:
        logit('No file part')
        flash('No file part')
        return redirect(request.url)
    
    file = request.files['videoFile']
    if file.filename == '':
        flash('No selected file')
        return redirect(request.url)
    
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['VUPLOAD_FOLDER'], filename))
        logit(f"Filename: {filename}")
        # Update the database with the filename
        update_video_filename(post_id, filename)
        flash('Video uploaded successfully')
        return redirect(url_for('post', post_id=post_id))
    else:
        flash('Allowed file types are .mp4')
        return redirect(request.url)

def update_video_filename(post_id, filename):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('UPDATE post SET video_filename = ? WHERE id = ?', (filename, post_id))
        conn.commit()

# Initialize SQLite database if not exists
def init_db():
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS post (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT UNIQUE,
                content TEXT NOT NULL,
                video_filename TEXT NULL,
                image BLOB
            )
        ''')
        conn.commit()

# Function to fetch a single post by ID
@app.route('/post/<int:post_id>', methods=['GET', 'POST'])
def post(post_id):
    if request.method == 'POST':
        return upload_video(post_id)

    post = get_post(post_id)
    if not post:
        flash('Post not found')
        return redirect(url_for('home'))

    image_data = get_image_data(post_id)
    video_filename = post[4] if post[4] else None  # Adjust index based on your database schema

    return render_template('post.html', post=post, image_data=image_data, video_filename=video_filename)


def get_post(post_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT id, title, content, image, video_filename FROM post WHERE id = ? ORDER BY id DESC', (post_id,))
        post = cursor.fetchone()
    return post
# Function to fetch all posts
def get_posts(limit=None):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        if limit:
            cursor.execute('SELECT id, title, content, image, video_filename FROM post ORDER BY id DESC LIMIT ?', (limit,))
        else:
            cursor.execute('SELECT id, title, content, image, video_filename FROM post ORDER BY id DESC')
        posts = cursor.fetchall()
    return posts

# Function to fetch image data
def get_image(post_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT image FROM post WHERE id = ?', (post_id,))
        post = cursor.fetchone()
        if post and post[0]:
            return post[0]  # Return base64 encoded image data
        return None

@app.route('/home2')
def home2():
    posts = get_posts(limit=6) 
    for post in posts:
        logit(post[3])# Limit to last 6 posts
    return render_template('home.html', posts=posts)

@app.route('/new', methods=['GET', 'POST'])
def new_post():
    if request.method == 'POST':
        title = request.form['title']
        content = request.form['content']
        image = request.files['image'].read() if 'image' in request.files and request.files['image'].filename != '' else None
        if image:
            image = base64.b64encode(image).decode('utf-8')
        with sqlite3.connect(DATABASE) as conn:
            cursor = conn.cursor()
            cursor.execute('INSERT INTO post (title, content, image) VALUES (?, ?, ?)', (title, content, image))
            conn.commit()
        flash('Post created successfully!', 'success')
        return redirect(url_for('home2'))
    return render_template('new_post.html')

@app.route('/edit/<int:post_id>', methods=['GET', 'POST'])
def edit_post(post_id):
    post = get_post(post_id)
    if request.method == 'POST':
        title = request.form['title']
        content = request.form['content']
        image_data = get_image(post_id)  # Get the current image data
        if 'image' in request.files and request.files['image'].filename != '':
            image = request.files['image'].read()
            image_data = base64.b64encode(image).decode('utf-8')  # Update with new image data
        with sqlite3.connect(DATABASE) as conn:
            cursor = conn.cursor()
            cursor.execute('UPDATE post SET title = ?, content = ?, image = ? WHERE id = ?', (title, content, image_data, post_id))
            conn.commit()
        flash('Post updated successfully!', 'success')
        return redirect(url_for('post', post_id=post_id))
    return render_template('edit_post.html', post=post)

@app.route('/contents')
def contents():
    posts = get_posts()
    contents_data = []
    for post in posts:
        excerpt = post[2][:300] + '...' if len(post[2]) > 300 else post[2]  # Assuming content is in the third column (index 2)
        contents_data.append({
            'id': post[0],
            'title': post[1],
            'excerpt': excerpt
        })
    return render_template('contents.html', contents_data=contents_data)

@app.route('/delete/<int:post_id>', methods=['POST'])
def delete_post(post_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('DELETE FROM post WHERE id = ?', (post_id,))
        conn.commit()
    flash('Post deleted successfully!', 'success')
    return redirect(url_for('home'))

def load_txt_files(directory):
    init_db()  # Initialize the SQLite database if not already created
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    try:
        for filename in os.listdir(directory):
            if filename.endswith('.txt'):
                filepath = os.path.join(directory, filename)
                with open(filepath, 'r', encoding='utf-8') as file:
                    title = os.path.splitext(filename)[0]
                    content = file.read()
                    cursor.execute('SELECT id FROM post WHERE title = ? ORDER BY id DESC', (title,))
                    existing_post = cursor.fetchone()
                    if not existing_post:
                        cursor.execute('INSERT INTO post (title, content) VALUES (?, ?)', (title, content))
                        conn.commit()
                        print(f'Added post: {title}')
                    else:
                        print(f'Skipped existing post: {title}')
    except sqlite3.Error as e:
        print(f'SQLite error: {e}')
    finally:
        conn.close()

@app.route('/search', methods=['GET', 'POST'])
def search():
    if request.method == 'POST':
        search_terms = request.form['search_terms']
        conn = sqlite3.connect(DATABASE)
        cursor = conn.cursor()
        
        # Define the search terms
        search_terms = search_terms.split(",")  # Split by comma to get individual search terms
        results = []
        
        # Construct the WHERE clause for the SQL query to filter rows based on all search terms
        where_conditions = []
        for term in search_terms:
            where_conditions.append(f"content LIKE ?")
        
        where_clause = " AND ".join(where_conditions)
        
        # Create a tuple of search terms with wildcard characters for the SQL query
        search_terms_tuple = tuple(f"%{term.strip()}%" for term in search_terms)
        
        # Execute the SELECT query with the constructed WHERE clause
        query = f"SELECT ROWID, title, content, image, video_filename FROM post WHERE {where_clause}"
        rows = cursor.execute(query, search_terms_tuple)
        
        for row in rows:
            results.append((row[0], row[1], row[2], row[3], row[4]))
        
        conn.close()
        return render_template('search.html', results=results)
    
    return render_template('search.html', results=[])


def get_image_data(post_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT image FROM post WHERE id = ?', (post_id,))
        post = cursor.fetchone()
        if post and post[0]:
            return base64.b64decode(post[0])  # Decode base64 to binary
        else:
            return None

@app.route('/post/<int:post_id>', methods=['GET', 'POST'])
def show_post(post_id):
    if request.method == 'POST':
        if 'videoFile' not in request.files:
            flash('No file part')
            return redirect(request.url)
        
        file = request.files['videoFile']

        if file.filename == '':
            flash('No selected file')
            return redirect(request.url)

        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file.save(os.path.join(app.config['VUPLOAD_FOLDER'], filename))
            
            with sqlite3.connect(DATABASE) as conn:
                cursor = conn.cursor()
                cursor.execute('UPDATE post SET video_filename = ? WHERE id = ?', (filename, post_id))
                conn.commit()
                flash('Video uploaded successfully')

            return redirect(url_for('show_post', post_id=post_id))

    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT id, title, content, image, video_filename FROM post WHERE id = ? ORDER BY id DESC', (post_id,))
        post = cursor.fetchone()
        if not post:
            flash('Post not found')
            return redirect(url_for('home'))
        
        image_data = base64.b64decode(post[3]) if post[3] else None
        video_filename = post[4] if post[4] else None
    logit(f"video_filename: {video_filename}")
    return render_template('post.html', post=post, image_data=image_data, video_filename=video_filename)

@app.route('/image/<int:post_id>')
def view_image(post_id):
    image_data = get_image_data(post_id)
    if image_data:
        return send_file(io.BytesIO(image_data), mimetype='image/jpeg')
    else:
        return "No image found", 404

TEXT_FILES_DIR = "static/TEXT" 
# Index route to display existing text files and create new ones
@app.route("/edit_text", methods=["GET", "POST"])
def edit_text():

    if request.method == "POST":
        filename = request.form["filename"]
        text = request.form["text"]
        save_text_to_file(filename, text)
        return redirect(url_for("edit_text"))
    else:
        # Path to the file containing list of file paths
        text_files = os.listdir(TEXT_FILES_DIR)
        text_directory='static/TEXT'
        files = sorted(text_files, key=lambda x: os.path.getmtime(os.path.join(text_directory, x)), reverse=True)
        #files=glob.glob('static/TEXT/*.txt')
        logit(f'files 1: {files}')  
        # Call the function to list files by creation time
        #files = list_files_by_creation_time(files)
        logit(f'files 2: {files}')
        return render_template("edit_text.html", files=files)
 # Route to edit a text file
@app.route("/edit/<filename>", methods=["GET", "POST"])
def edit(filename):
    if request.method == "POST":
        text = request.form["text"]
        save_text_to_file(filename, text)
        return redirect(url_for("index"))
    else:
        text = read_text_from_file(filename)
        return render_template("edit.html", filename=filename, text=text)
# Route to delete a text file
@app.route("/delete/<filename>")
def delete(filename):
    filepath = os.path.join(TEXT_FILES_DIR, filename)
    if os.path.exists(filepath):
        os.remove(filepath)
        logit(f"File deleted: {filename}")
    return redirect(url_for("index"))


def list_files_by_creation_time(file_paths):
    """
    List files by their creation time, oldest first.
    
    Args:
    file_paths (list): List of file paths.
    
    Returns:
    list: List of file paths sorted by creation time.
    """
    # Log the start of the function
    logit('Listing files by creation time...')
    
    # Create a dictionary to store file paths and their creation times
    file_creation_times = {}
    
    # Iterate through each file path
    for file_path in file_paths:
        # Get the creation time of the file
        try:
            creation_time = os.path.getctime(file_path)
            # Store the file path and its creation time in the dictionary
            file_creation_times[file_path] = creation_time
        except FileNotFoundError:
            # Log a warning if the file is not found
            logit(f'File not found: {file_path}')
    
    # Sort the dictionary by creation time
    sorted_files = sorted(file_creation_times.items(), key=lambda x: x[1],reverse=True)
    
    # Extract the file paths from the sorted list
    sorted_file_paths = [file_path for file_path, _ in sorted_files]
    
    # Log the end of the function
    logit('File listing complete.')
    
    # Return the sorted file paths
    return sorted_file_paths
def read_text_from_file(filename):
    filepath = os.path.join(TEXT_FILES_DIR, filename)
    with open(filepath, "r") as file:
        text = file.read()
        logit(f"Text read from file: {filename}")
        return text
    

@app.route('/generate', methods=['POST'])
def generate_text():
    input_text = request.form['input_text']
    generated_text = generate_text_with_model(input_text)
    logit(f"Generated text: {generated_text}")
    return jsonify({'generated_text': generated_text})

def generate_text_with_model(input_text):
    tokenizer = AutoTokenizer.from_pretrained("gpt2")
    model = AutoModelForCausalLM.from_pretrained("gpt2")
    tokenizer.pad_token = tokenizer.eos_token
    inputs = tokenizer(input_text, return_tensors="pt")
    input_ids = inputs["input_ids"]
    
    sample_output = model.generate(
        input_ids, 
        max_length=500, 
        temperature=0.8, 
        top_p=0.9, 
        do_sample=True,
        pad_token_id=tokenizer.pad_token_id
    )
    
    generated_text = tokenizer.decode(sample_output[0], skip_special_tokens=True)
    return generated_text

@app.route('/ask', methods=['GET', 'POST'])
def ask():
    return html_content
html_content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT-2 Text Generation</title>
    <link rel="stylesheet" href="static/dark.css">
    <style>
        textarea {
            width: 100% !important;
            height: 60px !important;
            margin: 10px 0;
            padding: 10px;
            font-size: 16px;
        }
        input[type="submit"] {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        </style>
</head>
<body>
    <h1>GPT-2 Text Generation</h1>
    <!-- Add link home -->
    <a href="/">Home</a>
    <form id="inputForm">
        <label for="input_text">Enter Input Text:</label><br>
        <textarea class="small" id="input_text" name="input_text"></textarea><br>
        <input type="submit" value="Generate Text">
    </form>
    <pre id="generated_text"></pre>
    <script>
        document.getElementById('inputForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            const formData = new FormData(this);
            const response = await fetch('/generate', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            document.getElementById('generated_text').innerHTML = '<h2>Generated Text:</h2>' + data.generated_text;
        });
    </script>
</body>
</html>
"""
def save_static_gallery_data(data):
    with open(STATIC_GALLERY_DATA_FILE, 'w') as f:
        json.dump(data, f)
    app.logger.info(f'Static gallery data saved to {STATIC_GALLERY_DATA_FILE}')

def load_static_gallery_data():
    # Scan directories if static gallery data file is missing or empty
    if not os.path.exists(STATIC_GALLERY_DATA_FILE):
        app.logger.info(f'{STATIC_GALLERY_DATA_FILE} not found. Scanning directories.')
        scan_directories() 
    else:           
        with open(STATIC_GALLERY_DATA_FILE, 'r') as f:
            data = json.load(f)
            app.logger.info(f'Static gallery data loaded from {STATIC_GALLERY_DATA_FILE}')
            return data
    return None

def scan_directories():
    image_dirs = []
    for root, dirs, files in os.walk('static/'):  # You can specify a specific directory to start scanning
        image_files = [f for f in files if os.path.splitext(f)[1].lower() in IMAGE_EXTENSIONS]
        if len(image_files) >= 20:
            image_dirs.append({
                'path': root,
                'images': image_files
            })
            app.logger.info(f'Found {len(image_files)} images in directory: {root}')
    return image_dirs

def save_scan_data(data):
    with open(SCAN_DATA_FILE, 'w') as f:
        json.dump(data, f)
    app.logger.info(f'Scan data saved to {SCAN_DATA_FILE}')

def load_scan_data():
    if os.path.exists(SCAN_DATA_FILE):
        with open(SCAN_DATA_FILE, 'r') as f:
            data = json.load(f)
            app.logger.info(f'Scan data loaded from {SCAN_DATA_FILE}')
            return data
    app.logger.info(f'{SCAN_DATA_FILE} not found.')
    return None

def select_random_images(image_dirs):
    gallery_data = []
    for dir_data in image_dirs:
        images = dir_data['images']
        if len(images) >= 20:
            sample_images = random.sample(images, 3)
            gallery_data.append({
                'directory': dir_data['path'],
                'images': [os.path.join(dir_data['path'], img) for img in sample_images]
            })
            app.logger.info(f'Selected images from directory: {dir_data["path"]}')
    return gallery_data

def copy_images_to_static(gallery_data):
    if not os.path.exists(STATIC_IMAGE_DIR):
        os.makedirs(STATIC_IMAGE_DIR)
        app.logger.info(f'Created directory: {STATIC_IMAGE_DIR}')

    static_image_paths = []
    for item in gallery_data:
        static_images = []
        for img_path in item['images']:
            img_name = os.path.basename(img_path)
            dest_path = os.path.join(STATIC_IMAGE_DIR, img_name)
            shutil.copy(img_path, dest_path)
            static_images.append(dest_path)
            app.logger.info(f'Copied image {img_name} to {STATIC_IMAGE_DIR}')
        static_image_paths.append({
            'directory': item['directory'],
            'images': static_images
        })
    return static_image_paths

@app.route('/gallery')
def gallery():
    scan_data = load_scan_data()
    if not scan_data:
        app.logger.info('No scan data found. Scanning directories.')
        scan_data = scan_directories()
        save_scan_data(scan_data)
        gallery_data = select_random_images(scan_data)
        static_gallery_data = copy_images_to_static(gallery_data)
    else:
        static_gallery_data = load_static_gallery_data()
        if not static_gallery_data:
            app.logger.info('No static gallery data found. Creating new static gallery data.')
            gallery_data = select_random_images(scan_data)
            static_gallery_data = copy_images_to_static(gallery_data)
            save_static_gallery_data(static_gallery_data)
    return render_template('gallery.html', gallery_data=static_gallery_data)


@app.route('/remove_images', methods=['GET', 'POST'])
def remove_images():
    folder = 'static/archived-store/'
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        if os.path.isfile(file_path):
            os.remove(file_path)
            logit(f"Removed file: {file_path}")
    return redirect(url_for('index'))

# Directory containing the images
archived_images_dir = 'static/archived-store'
#archived_images_dir = 'static/archived-images/'  # Update this path as needed

@app.route('/clean_storage', methods=['GET', 'POST'])
def clean_storage():
    if request.method == 'POST':
        # Get selected images
        selected_images = request.form.getlist('selected_images')
        
        if selected_images:
            # Generate a unique ID for the video file
            unique_id = str(uuid.uuid4())
            if not os.path.exists('static/image-archives'):
                os.makedirs('static/image-archives')
            video_filename = os.path.join('static/image-archives', f'{unique_id}.mp4')

            # Get image dimensions from the first image to set video size
            first_image_path = os.path.join(archived_images_dir, selected_images[0])
            first_image = cv2.imread(first_image_path)
            height, width, layers = first_image.shape
            
            # Define the video codec and create VideoWriter object
            video = cv2.VideoWriter(video_filename, cv2.VideoWriter_fourcc(*'mp4v'), 1, (width, height))

            # Write each image to the video
            for image in selected_images:
                image_path = os.path.join(archived_images_dir, image)
                img = cv2.imread(image_path)
                video.write(img)
            
            # Release the VideoWriter object
            video.release()

            # Remove selected images
            for image in selected_images:
                image_path = os.path.join(archived_images_dir, image)
                if os.path.exists(image_path):
                    os.remove(image_path)
        
        return redirect(url_for('clean_storage'))
    
    # Get list of images in the directory
    images = [os.path.basename(img) for img in glob.glob(os.path.join(archived_images_dir, '*.jpg'))]
    
    # Use `extend` to add PNG images to the list
    images.extend([os.path.basename(img) for img in glob.glob(os.path.join(archived_images_dir, '*.png'))])
    
    # Sort images by modification time
    images = sorted(images, key=lambda x: os.path.getmtime(os.path.join(archived_images_dir, x)), reverse=True) 
    
    return render_template('clean_storage.html', images=images)
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


@app.route('/upload', methods=['POST'])
def upload_file():
    # Check if the post request has the file part
    if 'file' not in request.files:
        flash('No file part')
        logit("No file part in request.")
        return redirect(request.url)

    file = request.files['file']

    # If user does not select file, browser also submits an empty part without filename
    if file.filename == '':
        flash('No selected file')
        logit("No file selected.")
        return redirect(request.url)

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(save_path)
        logit(f"File saved to {save_path}.")
        return redirect(url_for('uploaded_file', filename=filename))
    else:
        flash('File type not allowed')
        logit("File type not allowed.")
        return redirect(request.url)

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    # You can create a route to handle what happens after a file is uploaded successfully
    logit(f"File uploaded: {filename}.")
    return render_template ('uploaded_image.html', filename=filename)

    #return f"File {filename} uploaded successfully!"
    #-------------------------------
@app.route('/remove_image', methods=['GET', 'POST'])
def remove_image():
    folder = 'static/archived-images/'
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        if os.path.isfile(file_path):
            os.remove(file_path)
            logit(f"Removed file: {file_path}")
    return redirect(url_for('index'))

# Directory containing the images
archived_images = 'static/archived-images'
@app.route('/clean_archives', methods=['GET', 'POST'])
def clean_archives():
    if request.method == 'POST':
        # Get selected images
        selected_images = request.form.getlist('selected_images')
        #list of images sorted by creation time

        
        # Remove selected images
        for image in selected_images:
            image_path = os.path.join(archived_images, image)
            if os.path.exists(image_path):
                os.remove(image_path)
                logit(f"Removed image: {image_path}")
        
        return redirect(url_for('clean_archives'))
    
    # Get list of images in the directory (png and jpg)
    images = [os.path.basename(img) for img in glob.glob(os.path.join(archived_images, '*.png'))]
    images += [os.path.basename(img) for img in glob.glob(os.path.join(archived_images, '*.jpg'))]
    images = sorted(images, key=lambda x: os.path.getmtime(os.path.join(archived_images, x)), reverse=True)
    logit(f"clean_archives_Images: {images}")
    return render_template('clean_archives.html', images=images)

def create_backup_folder():
    backup_folder = os.path.join(os.getcwd(), "static", "Backups")
    if not os.path.exists(backup_folder):
        os.makedirs(backup_folder)
        logit(f"Backup folder created at: {backup_folder}")
@app.route('/edit_files', methods=['GET', 'POST'])
def edit_files():
    filename = request.args.get('filename', '')
    directory_path = "."
    PATH = os.getcwd()
    print("Current Directory:", PATH)
    full_path = os.path.join(PATH, directory_path, filename)

    print("Requested Filename:", filename)
    print("Directory Path:", directory_path)
    print("Full Path:", full_path)

    # Print the list of files in the directory for debugging purposes
    print("Files in Directory:", os.listdir(directory_path))

    if not os.path.exists(filename):
        return "File not found", 404

    if request.method == 'POST':
        content = request.form.get('content')
        
        if content is not None:
            date_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            new_filename = f"{os.path.splitext(filename)[0]}_{date_str}.txt"
            logit(f'File edited and saved as: {new_filename}')

            with open(os.path.join(directory_path, new_filename), 'w') as new_file:
                new_file.write(content)

            logit(f'File edited and saved as: {new_filename}')

            return send_file(os.path.join(directory_path, new_filename), as_attachment=True)

    with open(full_path, 'r') as file:
        content = file.read()

    return render_template('edit_files.html', filename=filename, content=content)

@app.route('/edit_html', methods=['POST', 'GET'])
def edit_html():
    path = currentDir+"/templates/"
    if request.method == 'POST':
        if 'load_file' in request.form:
            selected_file = request.form['selected_file']
            logit(f"Received request to load file: {selected_file}")
            file_path = os.path.join(path, selected_file)
            logit(f"Received request to load file: {file_path}")

            # Load the HTML content from the file
            html_content = load_html_file(file_path)
            logit(f"Loaded HTML content: {html_content}")

            # Pass the loaded content to the template
            return render_template('choose_file.html', files=choose_html(), file_path=file_path, html_content=html_content)

        elif 'edited_content' in request.form:
            edited_content = request.form['edited_content']
            file_path = os.path.join(path, request.form['selected_file'])

            # Save the edited HTML content
            with open(file_path, "w") as file:
                logit(f"Saving edited content to file: {file_path}")
                logit(f"Edited content: {edited_content}")
                file.write(edited_content)

    return render_template('choose_file.html', files=choose_html())


def load_html_file(file_path):
    with open(file_path, "r") as file:
        html_content = file.read()
        logit(f"Loaded HTML content from file: {file_path}")
        logit(f"HTML content: {html_content}")
    return html_content

def edit_html_file(file_path, new_content):
    with open(file_path, "w") as file:
        file.write(new_content)

def save_html_file(file_path, soup):
    with open(file_path, "w") as file:
        file.write(str(soup))
def choose_html():
    path = currentDir+"/templates/"
    files = glob.glob(path + "*.html")  # get all files in the directory

    if not files:
        print("No files found")
        return None
    return files

#remove just images from the static folder static/archived-store/ leave subfolders
TEMPLATE_DIR = 'templates'
@app.route('/html_index')
def html_index():
    # List all HTML files in the templates directory
    template_files = [f for f in os.listdir(TEMPLATE_DIR) if f.endswith('.html')]
    return render_template('html_index.html', template_files=template_files)

@app.route('/edit/<filename>', methods=['GET', 'POST'])
def edit_template(filename):
    file_path = os.path.join(TEMPLATE_DIR, filename)
    if request.method == 'POST':
        # Get the edited content from the form
        content = request.form['content']
        try:
            with open(file_path, 'w') as file:
                file.write(content)
            flash('Template updated successfully!', 'success')
        except Exception as e:
            flash(f'Error updating template: {str(e)}', 'danger')
        return redirect(url_for('index'))

    try:
        # Read the content of the template file
        with open(file_path, 'r') as file:
            content = file.read()
    except Exception as e:
        flash(f'Error reading template: {str(e)}', 'danger')
        return redirect(url_for('index'))
    
    return render_template('edit_html.html', filename=filename, content=content)

def feather_image(image, radius=50):
    """Applies a feathered transparency effect to the left and right edges of an image."""
    logit(f"Applying feather effect with radius {radius} to image of size {image.size}")
    
    mask = Image.new("L", image.size, 0)
    mask.paste(255, (radius, 0, image.width - radius, image.height))
    mask = mask.filter(ImageFilter.GaussianBlur(radius))
    
    image.putalpha(mask)
    return image

def create_seamless_image(images, feather_radius=5, overlap=100):
    """Creates a seamless image by blending the provided images with feathered edges and overlap."""
    total_width = sum(img.width for img in images) - overlap * (len(images) - 1)
    max_height = max(img.height for img in images)

    logit(f"Creating combined image of size {total_width}x{max_height}")
    
    combined_image = Image.new("RGBA", (total_width, max_height))

    x_offset = 0
    for i, img in enumerate(images):
        feathered_img = feather_image(img, feather_radius)
        combined_image.paste(feathered_img, (x_offset, 0), feathered_img)
        x_offset += img.width - overlap
        logit(f"Image {i+1} pasted at position {x_offset}")

    return combined_image

def make_scrolling_video(image_path, output_video_path, video_duration=10, video_size=(512, 768)):
    """Creates a video by scrolling across the image from left to right."""
    
    logit(f"Loading image from {image_path}")
    
    image = ImageClip(image_path)

    def scroll_func(get_frame, t):
        x = int((image.size[0] - video_size[0]) * t / video_duration)
        return get_frame(t)[0:video_size[1], x:x+video_size[0]]
    
    video = VideoClip(lambda t: scroll_func(image.get_frame, t), duration=video_duration)
    video = video.set_fps(24)

    logit(f"Saving video to {output_video_path}")
    video.write_videofile(output_video_path, codec='libx264', audio=False)

@app.route('/create_video', methods=['POST', 'GET'])
def create_video():
    """Endpoint to create a scrolling video from a set of images."""
    #copy static/temp_exp/TEMP2.mp4 static/temp_exp/diagonal1.mp4
    #shutil.copy("static/temp_exp/TEMP2.mp4", "static/temp_exp/diagonal1.mp4")
    try:
        vid_directory = 'static/archived-store'

        # Get all image files in the directory
        #image_files = glob.glob(os.path.join(vid_directory, '*.png'))
        image_files = glob.glob(os.path.join(vid_directory, '*.png')) + glob.glob(os.path.join(vid_directory, '*.jpg'))

        if not image_files:
            logit("No image files found.")
            return jsonify({"error": "No image files found."}), 404

        # Sort files by modification time
        image_files = sorted(image_files, key=os.path.getmtime, reverse=True)

        if len(image_files) < 6:
            logit("Less than 6 images found. Adjusting the number of selected images.")

        images = [Image.open(img).convert('RGBA').resize((512, 768), resample=Image.LANCZOS) for img in image_files[:8]]

        # Create the seamless image
        seamless_image_path = 'static/seamless_image.png'
        seamless_image = create_seamless_image(images, feather_radius=10, overlap=100)
        seamless_image.save(seamless_image_path)
        logit(f"Seamless image saved as {seamless_image_path}")

        # Create the scrolling video
        video_path = 'static/seamless_video.mp4'
        video_duration = 34
        video_size = (512, 768)
        make_scrolling_video(seamless_image_path, video_path, video_duration, video_size)
        
        # Optionally run external process if needed
        add_title_image(video_path, hex_color="#A52A2A")
        return redirect(url_for('index'))
    except Exception as e:
        return jsonify({"error": str(e)}), 500
        
def createvideo():
    try:
        vid_directory = 'static/archived-store'
        # Get all image files in the directory
        #image_files = glob.glob(os.path.join(vid_directory, '*.png'))
        image_files = glob.glob(os.path.join(vid_directory, '*.png')) + glob.glob(os.path.join(vid_directory, '*.jpg'))

        if not image_files:
            logit("No image files found.")
            return jsonify({"error": "No image files found."}), 404

        # Sort files by modification time
        image_files = sorted(image_files, key=os.path.getmtime, reverse=True)

        if len(image_files) < 6:
            logit("Less than 6 images found. Adjusting the number of selected images.")

        images = [Image.open(img).convert('RGBA').resize((512, 768), resample=Image.LANCZOS) for img in image_files[:8]]

        # Create the seamless image
        seamless_image_path = 'static/seamless_image.png'
        seamless_image = create_seamless_image(images, feather_radius=10, overlap=100)
        seamless_image.save(seamless_image_path)
        logit(f"Seamless image saved as {seamless_image_path}")

        # Create the scrolling video
        video_path = 'static/seamless_videoX.mp4'
        video_duration = 34
        video_size = (512, 768)
        make_scrolling_video(seamless_image_path, video_path, video_duration, video_size)
        
        # Optionally run external process if needed
        add_title_image(video_path, hex_color="#A52A2A")
        return redirect(url_for('index'))
    except Exception as e:
        logit(f"Error creating video: {e}")
        return jsonify({"error": str(e)}), 500


def add_title_image(video_path, hex_color = "#A52A2A"):
    hex_color=random.choice(["#A52A2A","#ad1f1f","#16765c","#7a4111","#9b1050","#8e215d","#2656ca"])
    # Define the directory path
    directory_path = "temp"
    # Check if the directory exists
    if not os.path.exists(directory_path):
        # If not, create it
        os.makedirs(directory_path)
        print(f"Directory '{directory_path}' created.")
    else:
        print(f"Directory '{directory_path}' already exists.") 
    # Load the video file and title image
    video_clip = VideoFileClip(video_path)
    print(video_clip.size)
    # how do i get the width and height of the video
    width, height = video_clip.size
    get_duration = video_clip.duration
    print(get_duration, width, height)
    title_image_path = "static/assets/512x568_border.png"
    # Set the desired size of the padded video (e.g., video width + padding, video height + padding)
    padded_size = (width + 50, height + 50)

    # Calculate the position for centering the video within the larger frame
    x_position = (padded_size[0] - video_clip.size[0]) / 2
    y_position = (padded_size[1] - video_clip.size[1]) / 2
    #hex_color = "#09723c"
    # Remove the '#' and split the hex code into R, G, and B components
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    # Create an RGB tuple
    rgb_tuple = (r, g, b)

    # Create a blue ColorClip as the background
    blue_background = ColorClip(padded_size, color=rgb_tuple)

    # Add the video clip on top of the red background
    padded_video_clip = CompositeVideoClip([blue_background, video_clip.set_position((x_position, y_position))])
    padded_video_clip = padded_video_clip.set_duration(video_clip.duration)
    #title_image_path = "/home/jack/Desktop/EXPER/static/assets/Title_Image02.png"
    # Load the title image
    title_image = ImageClip(title_image_path)

    # Set the duration of the title image
    title_duration = video_clip.duration
    title_image = title_image.set_duration(title_duration)

    print(video_clip.size)
    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("left", "top"))
    title_image = title_image.set_position((0, -5))
    #video_clip.size = (620,620)
    title_image = title_image.resize(padded_video_clip.size)

    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("center", "center")).resize(video_clip.size)

    # Create a composite video clip with the title image overlay
    composite_clip = CompositeVideoClip([padded_video_clip, title_image])
    # Limit the length to video duration
    composite_clip = composite_clip.set_duration(video_clip.duration)
    # Load a random background music
    mp3_files = glob.glob("/mnt/HDD500/collections/music_dark/*.mp3")
    random.shuffle(mp3_files)

    # Now choose a random MP3 file from the shuffled list
    mp_music = random.choice(mp3_files)
    get_duration = AudioFileClip(mp_music).duration
    # Load the background music without setting duration
    music_clip = AudioFileClip(mp_music)
    # Fade in and out the background music
    #music duration is same as video
    music_clip = music_clip.set_duration(video_clip.duration)
    # Fade in and out the background music
    fade_duration = 1.0
    music_clip = music_clip.audio_fadein(fade_duration).audio_fadeout(fade_duration)
    # Set the audio of the composite clip to the background music
    composite_clip = composite_clip.set_audio(music_clip)
    uid = uuid.uuid4().hex
    output_path = 'static/temp_exp/TEMP2X.mp4'
    # Export the final video with the background music
    composite_clip.write_videofile(output_path)
    mp4_file =  f"/mnt/HDD500/collections/vids/Ready_Post_{uid}.mp4"
    shutil.copyfile(output_path, mp4_file)     
    print(mp4_file)
    VIDEO = output_path
    return VIDEO
def add_title(video_path, hex_color = "#A52A2A"):
    hex_color=random.choice(["#A52A2A","#ad1f1f","#16765c","#7a4111","#9b1050","#8e215d","#2656ca"])
    # Define the directory path
    directory_path = "tempp"
    # Check if the directory exists
    if not os.path.exists(directory_path):
        # If not, create it
        os.makedirs(directory_path)
        print(f"Directory '{directory_path}' created.")
    else:
        print(f"Directory '{directory_path}' already exists.") 
    # Load the video file and title image
    video_clip = VideoFileClip(video_path)
    print(video_clip.size)
    # how do i get the width and height of the video
    width, height = video_clip.size
    get_duration = video_clip.duration
    print(get_duration, width, height)
    title_image_path = "static/assets/512x568_border.png"
    # Set the desired size of the padded video (e.g., video width + padding, video height + padding)
    padded_size = (width + 50, height + 50)

    # Calculate the position for centering the video within the larger frame
    x_position = (padded_size[0] - video_clip.size[0]) / 2
    y_position = (padded_size[1] - video_clip.size[1]) / 2
    #hex_color = "#09723c"
    # Remove the '#' and split the hex code into R, G, and B components
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    # Create an RGB tuple
    rgb_tuple = (r, g, b)

    # Create a blue ColorClip as the background
    blue_background = ColorClip(padded_size, color=rgb_tuple)

    # Add the video clip on top of the red background
    padded_video_clip = CompositeVideoClip([blue_background, video_clip.set_position((x_position, y_position))])
    padded_video_clip = padded_video_clip.set_duration(video_clip.duration)
    #title_image_path = "/home/jack/Desktop/EXPER/static/assets/Title_Image02.png"
    # Load the title image
    title_image = ImageClip(title_image_path)

    # Set the duration of the title image
    title_duration = video_clip.duration
    title_image = title_image.set_duration(title_duration)

    print(video_clip.size)
    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("left", "top"))
    title_image = title_image.set_position((0, -5))
    #video_clip.size = (620,620)
    title_image = title_image.resize(padded_video_clip.size)

    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("center", "center")).resize(video_clip.size)

    # Create a composite video clip with the title image overlay
    composite_clip = CompositeVideoClip([padded_video_clip, title_image])
    # Limit the length to video duration
    composite_clip = composite_clip.set_duration(video_clip.duration)
    # Load a random background music
    mp3_files = glob.glob("/mnt/HDD500/collections/music_dark/*.mp3")
    random.shuffle(mp3_files)

    # Now choose a random MP3 file from the shuffled list
    mp_music = random.choice(mp3_files)
    get_duration = AudioFileClip(mp_music).duration
    # Load the background music without setting duration
    music_clip = AudioFileClip(mp_music)
    # Fade in and out the background music
    #music duration is same as video
    music_clip = music_clip.set_duration(video_clip.duration)
    # Fade in and out the background music
    fade_duration = 1.0
    music_clip = music_clip.audio_fadein(fade_duration).audio_fadeout(fade_duration)
    # Set the audio of the composite clip to the background music
    composite_clip = composite_clip.set_audio(music_clip)
    uid = uuid.uuid4().hex
    output_path = 'static/temp_exp/TEMP1X.mp4'
    # Export the final video with the background music
    composite_clip.write_videofile(output_path)
    mp4_file =  f"/mnt/HDD500/collections/vids/Ready_Post_{uid}.mp4"
    shutil.copyfile(output_path, mp4_file)     
    print(mp4_file)
    VIDEO = output_path
    return VIDEO
def ensure_dir_exists(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

def next_points(point, imgsize, avoid_points=[], shuffle=True):
    point_list = [p for p in 
                  [(point[0], point[1]+1), (point[0], point[1]-1), 
                   (point[0]+1, point[1]), (point[0]-1, point[1])]
                  if 0 < p[0] < imgsize[0]//2 and 0 < p[1] < imgsize[1] and p not in avoid_points]

    if shuffle:
        random.shuffle(point_list)

    return point_list

def degrade_color(color, degradation=10):
    return tuple(min(c + degradation, 255) for c in color)

def spread(img, point, color, max_white=100, degradation=10):
    if color[0] <= max_white and img.getpixel(point)[0] > color[0]:
        img.putpixel(point, color)
        points = next_points(point, img.size, shuffle=False)
        color = degrade_color(color, degradation)
        for point in points:
            spread(img, point, color)

def binarize_array(numpy_array, threshold=200):
    return np.where(numpy_array > threshold, 255, 0)

def process_image(seed_count, seed_max_size, imgsize=(510, 766), count=0):
    margin_h, margin_v = 60, 60
    color = (0, 0, 0)
    img = Image.new("RGB", imgsize, "white")
    old_points = []
    posible_root_points = []

    for seed in range(seed_count):
        point = None
        while not point or point in old_points:
            point = (random.randrange(0 + margin_h, imgsize[0]//2), 
                     random.randrange(0 + margin_v, imgsize[1] - margin_v))
        old_points.append(point)
        posible_root_points.append(point)
        img.putpixel(point, color)

        seedsize = random.randrange(0, seed_max_size)
        flow = 0
        for progress in range(seedsize):
            flow += 1
            points = next_points(point, imgsize, old_points)
            try:
                point = points.pop()
            except IndexError:
                posible_root_points.remove(point)
                for idx in reversed(range(len(posible_root_points))):
                    points = next_points(posible_root_points[idx], imgsize, old_points)
                    try:
                        point = points.pop()
                        flow = 0
                        break
                    except IndexError:
                        posible_root_points.pop()
                if not point:
                    break

            old_points.append(point)
            posible_root_points.append(point)
            img.putpixel(point, color)

            for surr_point in points:
                spread(img, surr_point, degrade_color(color))

    cropped = img.crop((0, 0, imgsize[0]//2, imgsize[1]))
    img = img.transpose(Image.FLIP_LEFT_RIGHT)
    img.paste(cropped, (0, 0, imgsize[0]//2, imgsize[1]))
    img = img.filter(ImageFilter.GaussianBlur(radius=10))
    
    filename0 = "static/images/blot.png"
    img.save(filename0)

    im_grey = img.convert('LA')
    mean = np.mean(np.array(im_grey)[:, :, 0])

    image_file = Image.open(filename0)
    imagex = image_file.convert('L')
    imagey = np.array(imagex)
    imagez = binarize_array(imagey, mean)

    temp_filename = "static/images/tmmmp.png"
    cv2.imwrite(temp_filename, imagez)

    final_filename = time.strftime("static/archived-images/GOODblots%Y%m%d%H%M%S.png")
    ImageOps.expand(Image.open(temp_filename).convert("L"), border=1, fill='white').save(final_filename)

    print("GoodBlot: ", count)
    return final_filename

@app.route('/inkblot')
def rorschach():
    ensure_dir_exists("static/images")
    ensure_dir_exists("static/blot")

    # Generate the inkblots
    inkblot_images = []
    for count in range(2):  # Generate 2 inkblots as an example
        seed_count = random.randint(6, 10)
        seed_max_size = random.randint(5000, 16000)
        inkblot_image = process_image(seed_count, seed_max_size, count=count)
        inkblot_images.append(inkblot_image)

    # Pass the image paths to the template
    return render_template('Rorschach.html', inkblot_images=inkblot_images)
def size_and_format_images():
    """Resize and format the image to fit within the specified dimensions."""
    subpath = os.path.join('static', 'archived-store')
    #subprocess mogrifity -path subpath -resize 512x768 -format png image_path
    subprocess.run(["mogrify", "-path", subpath, "-resize", "512x768", "-format", "png"])
    return print("Image resized and formatted.")


# Function for image processing
def process_image(image_path):
    img = imread(image_path)
    labels = segmentation.slic(img, compactness=30, n_segments=400)
    g = future.graph.rag_mean_color(img, labels)

    def weight_boundary(graph, src, dst, n):
        default = {'weight': 0.0, 'count': 0}
        count_src = graph[src].get(n, default)['count']
        count_dst = graph[dst].get(n, default)['count']
        weight_src = graph[src].get(n, default)['weight']
        weight_dst = graph[dst].get(n, default)['weight']
        count = count_src + count_dst
        return {
            'count': count,
            'weight': (count_src * weight_src + count_dst * weight_dst) / count
        }

    def merge_boundary(graph, src, dst):
        pass

    labels2 = future.graph.merge_hierarchical(labels, g, thresh=0.08, rag_copy=False,
                                              in_place_merge=True,
                                              merge_func=merge_boundary,
                                              weight_func=weight_boundary)

    out = color.label2rgb(labels2, img, kind='avg')
    
    # Save the processed image
    output_filename = os.path.join(app.config['UPLOAD_FOLDER'], f"processed_{time.time()}.png")
    imsave(output_filename, out)
    return output_filename

# Route for the main page
@app.route('/uploadfile', methods=['GET', 'POST'])
def uploadfile():
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)
            
            # Process the image and get the output path
            processed_image_path = process_image(filepath)
            
            return redirect(url_for('uploaded_file', filename=os.path.basename(processed_image_path)))
    return '''
    <!doctype html>
    <title>Upload an image</title>
    <h1>Upload an image for segmentation processing</h1>
    <form method=post enctype=multipart/form-data>
      <input type=file name=file>
      <input type=submit value=Upload>
    </form>
    '''
    
try:
    os.makedirs("static/outlines")
except FileExistsError:
    # directory already exists
    pass
def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
def change_extension(orig_file,new_extension):
    p = change_ext(orig_file)
    new_name = p.rename(p.with_suffix(new_extension))
    return new_name
    
def FilenameByTime(directory):
    timestamp = str(time.time()).replace('.', '')
    filename = f"{directory}/{timestamp}.png"
    return filename

def auto_canny(image, sigma=0.33):
    v = np.median(image)
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    return edged

import os
import cv2
from PIL import Image
import shutil

def outlineJ(filename, sigma=0.33):
    # Load the image and apply Canny edge detection
    image = cv2.imread(filename)
    edged = auto_canny(image, sigma=sigma)
    
    # Invert the colors for black-and-white outlines
    inverted = cv2.bitwise_not(edged)
    
    # Paths to save the images
    temp_path = "static/outlines/temp2.png"
    outline_path = "static/outlines/outlined.png"
    transparent_path = "static/outlines/transparent_outline.png"

    # Save the inverted black-and-white image
    cv2.imwrite(temp_path, inverted)

    # Open the black-and-white outline image
    frontimage = Image.open(temp_path).convert("RGBA")  # Load as RGBA for transparency

    # Process to create the black outline with transparent background
    datas = frontimage.getdata()

    newData = []
    for item in datas:
        # If the pixel is white, make it transparent
        if item[0] > 200 and item[1] > 200 and item[2] > 200:  # Adjust as necessary
            newData.append((255, 255, 255, 0))
        else:
            newData.append((0, 0, 0, 255))  # Keep black as is

    frontimage.putdata(newData)
    frontimage.save(transparent_path)  # Save the transparent outline

    # Open the original image to apply the outline
    background = Image.open(filename).convert("RGBA")
    background.paste(frontimage, (3, 3), frontimage)  # Paste with transparency
    
    # Save the outlined image
    background.save(outline_path)

    # Save the outline on a white background
    outline_on_white = Image.new("RGBA", background.size, "WHITE")
    outline_on_white.paste(frontimage, (0, 0), frontimage)
    outline_on_white.save(temp_path)

    # Save the images with timestamps
    unique_id = uuid.uuid4().hex
    #savefile = f"static/outlines/{unique_id}.png"
    
    savefile = FilenameByTime("static/outlines")
    shutil.copyfile(transparent_path, f"static/archived-images/{unique_id}outlines_transparent.png")
    shutil.copyfile(outline_path, f"static/archived-images/{unique_id}_outlined.png")
    shutil.copyfile(temp_path, f"static/archived-images/{unique_id}_bw.png")
    
    return outline_path, transparent_path, temp_path


@app.route('/outlinefile', methods=['GET', 'POST'])
def outlinefile():
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)
            
            # Process the image and get the output path
            savefile, display_filename, temp_filename = outlineJ(filepath, sigma=0.33)
            return render_template('outlines.html', filename=display_filename, temp_filename=temp_filename)
    return '''
    <!doctype html>
    <title>Upload an image</title>
    <h1>Upload an image for outline processing</h1>
    <form method=post enctype=multipart/form-data>
      <input type=file name=file>
      <input type=submit value=Upload>
    </form>
    '''

#def allowed_file(filename):
#    return '.' in filename and filename.rsplit('.', 1)[1].lower() in{'png', 'jpg', 'jpeg', 'gif'}

# SQLite database setup functions
def get_db_connection():
    """
    Establishes a connection to the SQLite database.
    """
    try:
        conn = sqlite3.connect(DATABASEF)
        conn.row_factory = sqlite3.Row
        logit("Database connection established.")
        return conn
    except sqlite3.Error as e:
        logit(f"Error establishing database connection: {e}")
        traceback.print_exc()
        return None

def create_db():
    """
    Initializes the database by creating necessary tables if they don't exist.
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS functions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                function_text TEXT NOT NULL
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS metadata (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                key TEXT NOT NULL,
                value TEXT NOT NULL
            )
        ''')
        conn.commit()
        conn.close()
        logit(f"Database {DATABASEF} initialized.")
    except sqlite3.Error as e:
        logit(f"Error initializing database: {e}")
        traceback.print_exc()

def read_functions():
    """
    Reads all function texts from the database.
    """
    logit("Reading functions from database...")
    try:
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return []
        cursor = conn.cursor()
        cursor.execute('SELECT function_text FROM functions')
        functions = [row[0] for row in cursor.fetchall()]
        conn.close()
        logit("Functions retrieved from database.")
        return functions
    except sqlite3.Error as e:
        logit(f"Error reading functions: {e}")
        traceback.print_exc()
        return []

def insert_function(function_text):
    """
    Inserts a new function text into the database.
    """
    try:
        logit("Inserting function into database...")
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return
        cursor = conn.cursor()
        cursor.execute('INSERT INTO functions (function_text) VALUES (?)', (function_text,))
        conn.commit()
        conn.close()
        logit("Function inserted into database.")
    except sqlite3.Error as e:
        logit(f"Error inserting function: {e}")
        traceback.print_exc()

def insert_functions():
    """
    Inserts functions from 'con_html.txt' into the database if not already initialized.
    """
    logit("Checking if functions need to be inserted into the database...")
    try:
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return
        cursor = conn.cursor()
        cursor.execute("SELECT value FROM metadata WHERE key='initialized'")
        result = cursor.fetchone()
        if result is None:
            logit("Initializing and inserting functions from 'con_html.txt'...")
            with open('App_Sept03', 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
            # Assuming functions are separated by '\n.\n'
            segments = content.strip().split('@app')
            for segment in segments:
                cleaned_segment = segment.strip()
                if cleaned_segment:
                    cursor.execute('INSERT INTO functions (function_text) VALUES (?)', (cleaned_segment,))
            cursor.execute("INSERT INTO metadata (key, value) VALUES ('initialized', 'true')")
            conn.commit()
            logit("Functions inserted into database.")
        else:
            logit("Functions already inserted into database.")
        conn.close()
    except sqlite3.Error as e:
        logit(f"Error inserting functions into database: {e}")
        traceback.print_exc()

def get_last_function():
    """
    Retrieves the most recently inserted function from the database.
    """
    logit("Retrieving the last function from the database...")
    try:
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return None
        cursor = conn.cursor()
        cursor.execute('SELECT function_text FROM functions ORDER BY id DESC LIMIT 1')
        result = cursor.fetchone()
        conn.close()
        if result:
            logit("Last function retrieved successfully.")
            return result[0]
        else:
            logit("No functions found in the database.")
            return None
    except sqlite3.Error as e:
        logit(f"Error retrieving last function: {e}")
        traceback.print_exc()
        return None

@app.route('/index_code')
def index_code():
    """
    Renders the main index page with the latest function.
    """
    functions = get_last_function()
    return render_template('index_code.html', functions=functions)

@app.route('/save', methods=['POST'])
def save():
    """
    Saves the provided code and generates suggestions.
    """
    code = request.form['code']
    suggestions = generate_suggestions(code)
    return {'suggestions': suggestions}

def generate_suggestions(code):
    """
    Generates suggestions based on the last two words of the provided code.
    Each suggestion is approximately 400 characters long.
    """
    logit("Generating suggestions...")
    functions = read_functions()

    if not functions:
        logit("No functions available to generate suggestions.")
        return []

    # Retrieve the last line from the code
    lines = code.strip().split('\n')
    last_line = lines[-1] if lines else ''
    logit(f"Last line of code: '{last_line}'")

    # Split the last line into words and get the last two words
    words = last_line.split()
    last_two_words = ' '.join(words[-2:]) if len(words) >=2 else last_line
    logit(f"Last two words: '{last_two_words}'")

    # Function to split snippet based on last_two_words and return completion
    def split_snippet(snippet, last_two_words):
        index = snippet.rfind(last_two_words)
        if index != -1:
            completion = snippet[index + len(last_two_words):].strip()
            return completion
        return snippet.strip()

    # Search for matching snippets based on the last two words
    matching_snippets = []
    found_indices = set()  # To store indices of found snippets to avoid duplicates

    for i, snippet in enumerate(functions, start=1):
        if last_two_words in snippet:
            if i not in found_indices:
                found_indices.add(i)
                completion = split_snippet(snippet, last_two_words)
                formatted_snippet = f"<pre>{i}: {completion}</pre>"
                # Adjust the snippet length to approximately 400 characters
                if len(formatted_snippet) > 400:
                    formatted_snippet = formatted_snippet[:397] + '...'
                matching_snippets.append(formatted_snippet)
                logit(f"Added snippet {i}: {formatted_snippet}")

    # Return up to 20 suggestions, limited to 5 for demonstration purposes
    suggestions = matching_snippets[:5]
    logit(f"Generated {len(suggestions)} suggestions.")
    return suggestions

@app.route('/save_code', methods=['POST'])
def save_code():
    """
    Saves the provided code to the database.
    """
    code = request.data.decode('utf-8')
    logit(f"Received code to save: {code[:50]}...")  # Log first 50 characters for brevity
    if code:
        insert_function(code)
        return 'Code saved successfully', 200
    else:
        logit("No code provided in the request.")
        return 'No code provided in the request', 400

@app.route('/functions', methods=['GET', 'POST'])
def get_functions():
    """
    Retrieves all functions from the database and returns them as JSON.
    """
    logit("Fetching all functions from the database.")
    conn = get_db_connection()
    if conn is None:
        logit("Failed to establish database connection.")
        return jsonify([]), 500
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM functions')
    functions = cursor.fetchall()
    conn.close()
    logit(f"Retrieved {len(functions)} functions from the database.")
    return jsonify([dict(ix) for ix in functions])

@app.route('/functions/<int:id>', methods=['PUT', 'GET'])
def update_response(id):
    """
    Updates the function text for a given function ID.
    """
    new_response = request.json.get('function_text')
    logit(f"Updating function ID {id} with new text.")
    if not new_response:
        logit("No new function text provided.")
        return jsonify({'status': 'failure', 'message': 'No function text provided'}), 400
    try:
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return jsonify({'status': 'failure', 'message': 'Database connection failed'}), 500
        cursor = conn.cursor()
        cursor.execute('UPDATE functions SET function_text = ? WHERE id = ?', (new_response, id))
        conn.commit()
        conn.close()
        logit(f"Function ID {id} updated successfully.")
        return jsonify({'status': 'success', 'message': 'Function updated successfully'})
    except sqlite3.Error as e:
        logit(f"Error updating function ID {id}: {e}")
        traceback.print_exc()
        return jsonify({'status': 'failure', 'message': 'Error updating function'}), 500

@app.route('/view_functions', methods=['GET', 'POST'])
def view_functions():
    """
    Renders a page to view all functions.
    """
    logit("Rendering view_functions page.")
    conn = get_db_connection()
    if conn is None:
        logit("Failed to establish database connection.")
        return render_template('view_functions.html', data=[])
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM functions')
    data = cursor.fetchall()
    conn.close()
    logit(f"Retrieved {len(data)} functions for viewing.")
    return render_template('view_functions.html', data=data)

@app.route('/update_function', methods=['POST', 'GET'])
def update_function():
    """
    Updates a specific function based on form data and redirects to the view page.
    """
    id = request.form.get('id')
    new_function_text = request.form.get('function_text')
    logit(f"Received update for function ID {id}.")
    if not id or not new_function_text:
        logit("Missing function ID or new function text in the request.")
        return redirect(url_for('view_functions'))
    try:
        conn = get_db_connection()
        if conn is None:
            logit("Failed to establish database connection.")
            return redirect(url_for('view_functions'))
        cursor = conn.cursor()
        cursor.execute('UPDATE functions SET function_text = ? WHERE id = ?', (new_function_text, id))
        conn.commit()
        conn.close()
        logit(f"Function ID {id} updated successfully via form.")
        return redirect(url_for('view_functions'))
    except sqlite3.Error as e:
        logit(f"Error updating function ID {id}: {e}")
        traceback.print_exc()
        return redirect(url_for('view_functions'))

def get_suggestions(search_term):
    try:
        # Create a database connection
        conn = sqlite3.connect(':memory:')
        c = conn.cursor()

        # Create table
        c.execute('''CREATE TABLE IF NOT EXISTS dialogue
                     (id INTEGER PRIMARY KEY,
                      search_term TEXT,
                      ChatGPT_PAIR TEXT,
                      ChatGPT_PAIRb BLOB
                      )''')
        conn.commit()

        # Perform operations
        cnt = 0
        DATA = set()
        INDEX = '----SplitHere------'
        with open("App_Sept03", "r") as data:
            Lines = data.read()
            lines = Lines.replace(search_term, INDEX + search_term)
            lines = lines.split(INDEX)
            for line in lines:
                if search_term in line:
                    cnt += 1
                    DATA.add(f'{line[:1200]}')
                    # Insert dialogue pair into the table
                    c.execute("INSERT INTO dialogue (search_term, ChatGPT_PAIR, ChatGPT_PAIRb) VALUES (?, ?, ?)",
                              (search_term, line, line.encode('utf-8')))
                    conn.commit()

        # Close the database connection
        conn.close()
        return DATA
    except Exception as e:
        logging.error(f"An error occurred: {e}")
        return set()

@app.route('/search_file', methods=['GET', 'POST'])
def search_file():
    search_term = request.args.get('q', '') if request.method == 'GET' else request.form.get('q', '')
    if search_term:
        data = get_suggestions(search_term)
        return render_template_string('''
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Search Results</title>
        </head>
        <body>
            <h1>Search Results for "{{ search_term }}"</h1>
            {% for item in data %}
                <div style="border-bottom: 1px solid #ccc; padding: 10px;">
                    <pre>{{ item }}</pre>
                </div>
            {% endfor %}
            <a href="/search_file">Search Again</a>
        </body>
        </html>
        ''', search_term=search_term, data=data)
    else:
        return render_template_string('''
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Enter Search Term</title>
        </head>
        <body>
            <h1>Enter a Search Term</h1>
            <form action="/search_file" method="post">
                <input type="text" name="q" placeholder="Enter search term">
                <input type="submit" value="Search">
            </form>
        </body>
        </html>
        ''')

if __name__ == '__main__':
    create_db()
    #remove log file
    log_file = "static/app_log.txt"
    if os.path.exists(log_file):
        os.remove(log_file)
    directory = 'static/TEXT'
    load_txt_files(directory)
    app.run(debug=True, host='0.0.0.0', port=5000)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Add Text to Image</title>
    <style>
        body {
            background-color: #2b2b2b;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 30px;
        }
        .container {
            margin: 50px;
        }
        input[type="text"], input[type="number"], select {
            color: black;
        }
        img {
            margin-top: 20px;
            max-width: 100%;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .in_s{
            width: 80%;
            height: 50px;
            font-size: 30px;
        }
        .image-preview {
            display: inline-block;
            text-align: center;
            margin: 10px;
            cursor: pointer;
        }
        .image-preview img {
            max-width: 200px;
            max-height: 300px;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        .image-preview.selected img {
            border-color: orange;
        }
    </style>
    <script>
        function selectImage(imageFile) {
            document.getElementById('image_file').value = imageFile;
            var previews = document.querySelectorAll('.image-preview');
            previews.forEach(function(preview) {
                preview.classList.remove('selected');
            });
            document.getElementById('preview-' + imageFile).classList.add('selected');
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>Add Text to Image</h1>
        <a href="{{ url_for('index') }}" style="font-size: 30px;color: chocolate;">Back to Home</a><br/><br/>
        
        <a href="{{ url_for('add_text') }}" style="font-size: 30px;color: chocolate;">Reload</a>
        <form method="POST">
            <div class="form-group">
                <label>Select an image:</label>
                <div id="image-previews">
                    {% for image in images %}
                    <div id="preview-{{ image }}" class="image-preview" onclick="selectImage('{{ image }}')">
                        <img src="{{ url_for('static', filename='archived-store/' + image) }}" alt="{{ image }}">
                        <br>{{ image }}
                    </div>
                    {% endfor %}
                </div>
                <input type="hidden" id="image_file" name="image_file" value="{% if selected_image %}{{ selected_image }}{% endif %}" required>
            </div>
            <div class="form-group">
                <label for="text">Text to add:</label>
                <input class="in_s" type="text" name="text" required>
            </div>
            <div class="form-group">
                <label for="x_position">X Position:</label>
                <input class="in_s" type="number" name="x_position" value="50" required>
            </div>
            <div class="form-group">
                <label for="y_position">Y Position:</label>
                <input class="in_s" type="number" name="y_position" value="50" required>
            </div>
            <div class="form-group">
                <label for="font_size">Font Size:</label>
                <input class="in_s" type="number" name="font_size" value="30" required>
            </div>
            <div class="form-group">
                <label for="color">Text Color:</label>
                <select class="in_s" name="color">
                    <option class="in_s" value="red">Red</option>
                    <option class="in_s" value="blue">Blue</option>
                    <option class="in_s" value="yellow">Yellow</option>
                    <option class="in_s" value="orange">Orange</option>
                </select>
            </div>
            <button type="submit">Preview</button>
        </form>

        {% if temp_image %}
        <hr>
        <h2>Preview</h2>
        <img src="{{ url_for('static', filename='temp/' + temp_image) }}" alt="Image Preview">
        <form method="POST" action="{{ url_for('save_image') }}">
            <input type="hidden" name="image_file" value="{{ selected_image }}">
            <input type="hidden" name="final_text" value="{{ text }}">
            <input type="hidden" name="final_position" value="{{ position }}">
            <input type="hidden" name="final_font_size" value="{{ font_size }}">
            <input type="hidden" name="final_color" value="{{ color }}">
            <button type="submit">Save Image</button>
        </form>
        {% endif %}
    </div>
</body>
</html>
<!-- Description: HTML template for the application overview page -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask-Based Image and Video Processing Application</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #98de91;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #21f356;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #007BFF;
        }
        h1 {
            border-bottom: 2px solid #007BFF;
            padding-bottom: 10px;
        }
        ul {
            list-style: none;
            padding: 0;
        }
        ul li {
            margin: 10px 0;
        }
        .feature-list, .use-case-list {
            padding-left: 20px;
        }
        .feature-list li, .use-case-list li {
            background: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .conclusion {
            padding: 20px;
            background: #e9ecef;
            border-radius: 5px;
        }
        footer {
            margin-top: 20px;
            text-align: center;
            padding: 10px;
            background: #007BFF;
            color: #fff;
            border-radius: 5px;
        }
        pre {
            background: #ccedbf;
            width: 85%;
            margin: 0 auto;
            padding: 20px;
            border-radius: 5px;
            margin-top: 20px;
            white-space: pre-wrap;
        }
       
        body {
            background-color: #2C2C2C;
            color: rgb(27, 1, 1);
            font-family: Arial, sans-serif;
        }
        .refresh-button {
            display: inline-block;
            padding: 5px 10px;
            font-size: 16px;
            background-color: #5C5CFF;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 1px;
        }
        .refresh_button {
            display: inline-block;
            padding: 5px 10px;
            font-size: 24px;
            background-color: #ffcd04;
            color: rgb(61, 142, 235);
            text-decoration: underline;
            border-radius: 5px;
            margin: 1px;
        }
        .refresh-button:hover {
            background-color: #3C3CFF;
        }
    </style>
    </style>
</head>
<body>
    <div class="container">
        <h1>Flask-Based Image and Video Processing Application</h1>
        <a href="{{ url_for('index') }}" class="refresh_button">HOME</a>
        <h1>Audio Player</h1>
        <audio controls>
            <source src="{{ url_for('static', filename='audio/narration.mp3') }}" type="audio/mp3">
            Your browser does not support the audio element.
        </audio>
        
        
        <h2>Application Overview</h2>
        <p>This Flask-based application is a versatile tool for image and video processing, particularly geared towards creating, manipulating, and blending images for various creative projects. The application supports multiple functionalities, including image uploads, grayscale and binary mask generation, image blending, and video frame extraction. It's designed to provide a smooth user experience for managing and processing media files within a structured web interface.</p>

        <h2>Key Features</h2>
        <p>
        <a href="{{ url_for('refresh_images') }}" class="refresh-button">Refresh Images</a><br/>
    This command loads 25 images. I save my images as videos so they may be retrieved for projects such as this. This selects twenty five videos and an image from each one to add to the resources. </p> 
        <p><a href="{{ url_for('display_resources') }}" class="refresh-button">Display Resource Images</a><br/>
        Display resource images Will display all images available for compositing.</p>
        <p><a href="{{ url_for('select_images') }}" class="refresh-button">Select Images to Blend</a><br/>
        The available images are displayed here. At this point you may choose a top image a mask and a bottom image. Then at the bottom of the page SUBMIT. The images will be composited and displayed. All images that have been created will be displayed. However, the last image will be shown first.</p><br/>
            <p><a href="{{ url_for('index_upload') }}" class="refresh-button">Upload a Specific Image</a><br/>
            Here you may select an image to add to you resources. As you see Last is displayed first. </p><br/>
        <a href="{{ url_for('get_video_images') }}" class="refresh-button">Get Images from YouTube Videos</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('face_detect') }}" class="refresh-button">Get Image For Face Detection</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('refresh_video') }}" class="refresh-button">Make Video</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('select_mask_image') }}" class="refresh-button">Special Mask -Choice-</a>
        <hr>
        <form action="/get_images" method="post">
            <button type="submit">Get Three Random Images</button>
        <h3>Image Uploading and Storage:</h3>
        <ul class="feature-list">
            <li>Users can upload images in various formats (PNG, JPG, JPEG, GIF) through a user-friendly web interface.</li>
            <li>Uploaded images are securely stored in designated directories (static/archived-images), ensuring easy access and management.</li>
            <li>Uploaded images are automatically organized by upload time, with the most recent images displayed first.</li>
        </ul>
        
        <h3>Mask Generation:</h3>
        <ul class="feature-list">
            <li>The application allows users to create masks for images using two different methods:</li>
            <ul>
                <li><strong>Grayscale Masking:</strong> Converts an image to grayscale and uses it as a mask for blending purposes.</li>
                <li><strong>Binary Masking:</strong> Converts an image to a binary format by calculating the mean pixel value and using it as a threshold. The resulting binary mask can be inverted for alternative effects.</li>
            </ul>
            <li>These masks are saved in the static/archived-masks directory and can be applied to other images within the application.</li>
        </ul>

        <h3>Image Blending:</h3>
        <ul class="feature-list">
            <li>Users can blend two images using a selected mask (either grayscale or binary) with adjustable opacity settings.</li>
            <li>The blending process is performed using the Pillow library, and the final blended image is saved in the static/archived-store directory.</li>
            <li>The application ensures that the dimensions of all images involved in blending are consistent by resizing them to a standard size (512x768 pixels).</li>
        </ul>

        <h3>Video Frame Extraction:</h3>
        <ul class="feature-list">
            <li>The application can extract random frames from a video file, enabling users to generate a series of images from their video content.</li>
            <li>Extracted frames are saved in the static/archived-images directory for further manipulation or use in blending processes.</li>
        </ul>

        <h3>Image Selection and Mask Application:</h3>
        <ul class="feature-list">
            <li>Users can select images for further processing, such as applying masks or blending with other images.</li>
            <li>The application supports a selection workflow that allows users to preview and choose their desired images and masks through an intuitive web interface.</li>
        </ul>

        <h3>Logging and Debugging:</h3>
        <ul class="feature-list">
            <li>The application is equipped with a robust logging system that tracks actions and errors throughout the execution. Logs are saved to a file (exp_log.txt), providing detailed insights into the application’s behavior for debugging and monitoring purposes.</li>
        </ul>

        <h3>Subprocess Integration:</h3>
        <ul class="feature-list">
            <li>Certain features, like refreshing images or videos, are handled by external Python scripts. These scripts are executed through subprocess calls, allowing the application to manage complex tasks without blocking the main process.</li>
            <li>This modular approach ensures that the application remains responsive and can handle additional processing in the background.</li>
        </ul>

        <h2>Use Cases</h2>
        <ul class="use-case-list">
            <li><strong>Creative Projects:</strong> Ideal for artists and designers who want to experiment with image blending and masking techniques to create unique visual compositions.</li>
            <li><strong>Video Processing:</strong> Useful for content creators who need to extract and manipulate frames from their video files for promotional materials or other purposes.</li>
            <li><strong>Web-Based Media Management:</strong> Provides a centralized platform for managing, processing, and storing images and videos in a structured and organized manner.</li>
        </ul>

        <h2>Conclusion</h2>
        <div class="conclusion">
            <p>This application serves as a comprehensive toolkit for image and video processing, blending artistic creativity with technical precision. Whether you are working on a digital art project, creating promotional content, or simply experimenting with visual effects, this application offers the tools and flexibility you need to bring your ideas to life.</p>
        </div>
    </div>

    <footer>
        <p>&copy; 2024 Flask-Based Image and Video Processing Application. All Rights Reserved.</p>
    </footer>
</body>
</html>
<pre>Application Overview
    Application Overview
This Flask-based application is a versatile tool for image and video processing, particularly geared towards creating, manipulating, and blending images for various creative projects. The application supports multiple functionalities, including image uploads, grayscale and binary mask generation, image blending, and video frame extraction. It's designed to provide a smooth user experience for managing and processing media files within a structured web interface.

Key Features
Image Uploading and Storage:

Users can upload images in various formats (PNG, JPG, JPEG, GIF) through a user-friendly web interface.
Uploaded images are securely stored in designated directories (static/archived-images), ensuring easy access and management.
Uploaded images are automatically organized by upload time, with the most recent images displayed first.
Mask Generation:

The application allows users to create masks for images using two different methods:
Grayscale Masking: Converts an image to grayscale and uses it as a mask for blending purposes.
Binary Masking: Converts an image to a binary format by calculating the mean pixel value and using it as a threshold. The resulting binary mask can be inverted for alternative effects.
These masks are saved in the static/archived-masks directory and can be applied to other images within the application.
Image Blending:

Users can blend two images using a selected mask (either grayscale or binary) with adjustable opacity settings.
The blending process is performed using the Pillow library, and the final blended image is saved in the static/archived-store directory.
The application ensures that the dimensions of all images involved in blending are consistent by resizing them to a standard size (512x768 pixels).
Video Frame Extraction:

The application can extract random frames from a video file, enabling users to generate a series of images from their video content.
Extracted frames are saved in the static/archived-images directory for further manipulation or use in blending processes.
Image Selection and Mask Application:

Users can select images for further processing, such as applying masks or blending with other images.
The application supports a selection workflow that allows users to preview and choose their desired images and masks through an intuitive web interface.
Logging and Debugging:

The application is equipped with a robust logging system that tracks actions and errors throughout the execution. Logs are saved to a file (exp_log.txt), providing detailed insights into the application’s behavior for debugging and monitoring purposes.
Subprocess Integration:

Certain features, like refreshing images or videos, are handled by external Python scripts. These scripts are executed through subprocess calls, allowing the application to manage complex tasks without blocking the main process.
This modular approach ensures that the application remains responsive and can handle additional processing in the background.
Web Interface and Routing:

The application provides a clean and organized web interface, allowing users to navigate between different functionalities, such as uploading files, selecting images, creating masks, and viewing results.
All major actions are linked to specific routes (/upload, /blend_images, /get_video_images, etc.), making the application easy to extend and maintain.
Use Cases
Creative Projects: Ideal for artists and designers who want to experiment with image blending and masking techniques to create unique visual compositions.
Video Processing: Useful for content creators who need to extract and manipulate frames from their video files for promotional materials or other purposes.
Web-Based Media Management: Provides a centralized platform for managing, processing, and storing images and videos in a structured and organized manner.
Conclusion
This application serves as a comprehensive toolkit for image and video processing, blending artistic creativity with technical precision. Whether you are working on a digital art project, creating promotional content, or simply experimenting with visual effects, this application offers the tools and flexibility you need to bring your ideas to life. With its user-friendly interface, versatile functionalities, and robust backend processing, the application empowers users to explore new possibilities in image manipulation and content creation.</pre><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='dark.css') }}">
    <script>
        function findString(str) {
            if (parseInt(navigator.appVersion) < 4) return;

            if (window.find) {
                var strFound = window.find(str);
                if (!strFound) {
                    window.find(str, 0, 1);
                }
                if (strFound) {
                    var range = window.getSelection().getRangeAt(0);
                    var span = document.createElement("span");
                    span.style.backgroundColor = "yellow";
                    range.surroundContents(span);
                }
            } else if (navigator.appName.indexOf("Microsoft") != -1) {
                // Not implemented for brevity
            } else if (navigator.appName == "Opera") {
                alert("Opera browsers not supported, sorry...");
                return;
            }

            if (!strFound) alert("String '" + str + "' not found!");
        }

        function moveToNextOccurrence() {
            var search_str = document.getElementById("search_input").value;
            findString(search_str);
        }
    </script>

</head>
<style>
    .sticky {
        position: -webkit-sticky;
        margin-left: auto;
        margin-right: auto;
        position: sticky;
        top: 0;
        text-align: center!important;
        padding: 10px 0;
        z-index: 1000;
        width: 100%!important;
    }
</style>

<body>
    <header class="sticky">
        <span>FlaskArchitect Blog</span>&nbsp;&nbsp;|&nbsp;&nbsp;
        <a href="{{ url_for('index') }}">App Home</a>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="{{ url_for('home2') }}">Text Home</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="{{ url_for('gallery') }}">Gallery</a>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="{{ url_for('edit_text') }}">Edit Text File</a>&nbsp;&nbsp;|&nbsp;&nbsp;
             <a href="{{ url_for('new_post') }}">Create New Post</a><br>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="{{ url_for('remove_images') }}">Remove_images from Store</a>&nbsp;&nbsp;|&nbsp;&nbsp;
          
            <a href="{{ url_for('contents') }}">View All Contents</a>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="{{ url_for('ask') }}">Ask GPT2</a>&nbsp;&nbsp;|&nbsp;&nbsp;

            
            <a href="{{ url_for('view_log') }}">View Log</a>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="{{ url_for('search') }}">Search</a>
            <input type="text" id="search_input" />
            <button id="search_submit" onclick="moveToNextOccurrence()">
                Find in page Next
              </button>
        
    </header>
    <main>
        {% block content %}{% endblock %}
    </main>
    <footer>
        <p>&copy; 2024 FlaskArchitect Blog</p>
    </footer>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Blended Result</title>
</head>
<body  style="background-color: cadetblue;padding-left: 40px;">
    <h1  style="color: orange;">Blended Image Result and Mask</h1>

    <form action="/store_result" method="post">
        <input type="hidden" name="result_image" value="{{ url_for('static', filename='archived-images/result.png') }}">
        <button type="submit">Store Result</button>
    </form>
    <form action="/edit_mask" method="post">
        {% for image_path in image_paths %}
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
        <!--input type="hidden" name="opacity" value="{{ opacity }}"-->
        <label for="opacity">Opacity (between 0 and 1):</label>
        <input type="text" id="opacity" name="opacity" value="{{ opacity }}">
        <button type="submit">Edit Mask and Blend Again</button>
    </form>
    <!-- return home -->
    <form action="/" method="get">
        <button type="submit">Home</button>
    </form>
    <br/><br/><img src="{{ url_for('static', filename='archived-images/result.png') }}" width="300px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <img src="{{ url_for('static', filename='masks/mask.png') }}" width="300px">
 </body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Blended Result</title>
</head>
<body  style="background-color: cadetblue;">
    <h1  style="color: orange;">Blended Image Result</h1>

    <form action="/store_result" method="post">
        <input type="hidden" name="result_image" value="{{ url_for('static', filename='images/result.png') }}">
        <button type="submit">Store Result</button>
    </form>
    <form action="/edit_mask" method="post">
        {% for image_path in image_paths %}
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
        <input type="hidden" name="opacity" value="{{ opacity }}">
        <button type="submit">Edit Mask and Blend Again</button>
    </form>
    <!-- return home -->
    <form action="/" method="get">
        <button type="submit">Home</button>
    </form>
    <img src="{{ url_for('static', filename='images/result.png') }}" width="400px">
</body>
</html>
<!-- This is the HTML file that allows the user to choose which HTML file to edit. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choose HTML File</title>
</head>
<body>
    <h1>Choose HTML File</h1>

    <form action="/edit_html" method="post">
        <label for="selected_file">Select an HTML file:</label>
        <select name="selected_file" id="selected_file">
            {% for file in files %}
                <option value="{{ file }}">{{ file }}</option>
            {% endfor %}
        </select>
        <br>

        <!-- Add a Load File button -->
        <button type="button" onclick="loadFile()">Load File</button>
        <br>

        <label for="edited_content">Edit the HTML content:</label>
        <textarea name="edited_content" id="edited_content" rows="10" cols="80"></textarea>
        <br>
        <input type="submit" value="Save Changes">
    </form>

    <script>
        function loadFile() {
            var selectedFile = document.getElementById("selected_file").value;

            // Make an AJAX request to load the content of the selected file
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // Update the textarea with the loaded content
                    document.getElementById("edited_content").value = JSON.parse(xhr.responseText)['html_content'];
                }
            };
            xhr.open("GET", "/load_file?file=" + selectedFile, true);
            xhr.send();
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choose Mask Type</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #c7c7c7;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .form-container {
            text-align: center;
            margin-top: 20px;
        }
        .form-container select, .form-container button {
            background-color: #007bff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .form-container button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Choose Mask Type</h1>
    <form action="{{ url_for('choose_mask') }}" method="post">
        <input type="hidden" name="selected_image" value="{{ selected_image }}">
        <div class="form-container">
            <select name="mask_type">
                <option value="grayscale">Grayscale</option>
                <option value="binary">Binary</option>
            </select>
            <button type="submit">Generate Mask</button>
        </div>
    </form>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Selection</title>
    <style>
        body {
            background-color: #2c2c2c;
            color: #f5f5f5;
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
        }
        .image-box {
            margin: 10px;
            text-align: center;
        }
        img {
            max-width: 150px;
            max-height: 150px;
            display: block;
            margin-bottom: 5px;
            border-radius: 8px;
        }
        .btn-submit {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-submit:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>Select Images to Remove</h1>
    <a style="font-size: 30px;color: chocolate;"href="{{ url_for('index') }}">Back to Home</a>
    <p>Check the images you want to remove from the archives.</p>
    <form method="POST" action="{{ url_for('clean_archives') }}">
        <div class="image-container">
            {% for image in images %}
            <div class="image-box">
                <img src="{{ url_for('static', filename='archived-images/' + image) }}" alt="{{ image }}">
                <input type="checkbox" name="selected_images" value="{{ image }}">
            </div>
            {% endfor %}
        </div>
        <button type="submit" class="btn-submit">Remove Selected Images</button>
    </form>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Selection</title>
    <style>
        body {
            background-color: #2c2c2c;
            color: #f5f5f5;
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center!important;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center
        }
        .image-box {
            margin: 10px;
            text-align: center;
        }
        img {
            max-width: 300px;
            max-height: 400px;
            display: block;
            margin-bottom: 5px;
            border-radius: 8px;
        }
        .btn-submit {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-submit:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>

    <h1>Select Images to Remove</h1>
    <a style="font-size: 30px;color: chocolate;"href="{{ url_for('index') }}">Back to Home</a>
    <p>Check the images you want to remove from the storage.</p>
    <form method="POST" action="{{ url_for('clean_storage') }}">
        <div class="image-container">
            {% for image in images %}
            <div class="image-box">
                <img src="{{ url_for('static', filename='archived-store/' + image) }}" alt="{{ image }}">
                <input type="checkbox" name="selected_images" value="{{ image }}">
            </div>
            {% endfor %}
        </div>
        <button type="submit" class="btn-submit">Remove Selected Images</button>
    </form>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Extracted Clips</title>
</head>
<body>
    <h1>Extracted Clips</h1>
    <div>
        {% for clip in clips %}
            <video width="320" height="240" controls>
                <source src="{{ clip }}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <br>
        {% endfor %}
    </div>
    <a href="/">Back</a>
</body>
</html>
<!-- confirm_image.html -->
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confirm Image</title>
</head>
<body>
    <h1>Confirm Image</h1>
    <img src="{{ url_for('static', filename=image_path.split('/')[-1]) }}" alt="Uploaded Image" style="max-width:100%; height:auto;">
    <form action="/torn_edge" method="POST">
        <input type="hidden" name="image_path" value="{{ image_path }}">
        <button type="submit">Apply Torn Edge Effect</button>
    </form>
</body>
</html>
{% extends 'base.html' %}

{% block title %}Contents{% endblock %}

{% block content %}
<h2>All Contents</h2>
<ul>
    {% for content in contents_data %}
    <li>
        <h3>{{content.id}}: {{ content.title }}</h3>
        <pre>{{ content.excerpt }}</pre>
        <a href="{{ url_for('show_post', post_id=content.id) }}">Read more</a>&nbsp;&nbsp;  |  &nbsp;&nbsp;
        <a href="{{ url_for('edit_post', post_id=content.id) }}">Edit</a>
    </li>
    <hr>
    {% endfor %}
</ul>
<a href="{{ url_for('home2') }}">Back to Home</a>
{% endblock %}
<!DOCTYPE html>
<html>
<head>
    <title>Display Images</title>
</head>
<body  style="background-color: cadetblue;">
    <h1 style="color: orange;" >Randomly Selected Images</h1>

    <form action="/edit_mask" method="post">
        {% for image_path in image_paths %}
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
        <input type="hidden" name="opacity" value="{{ opacity }}">
        <button type="submit">Edit Mask and Blend Again</button>
    </form>
        <!-- return home -->
        <form action="/" method="get">
            <button type="submit">Home</button>
        </form>
    <form action="/blend_images" method="post">
      
        <label for="opacity">Opacity (between 0 and 1):</label>
        <input type="text" id="opacity" name="opacity" value="{{ opacity }}">
      
        <button type="submit">Blend Images with Mask</button>&nbsp;&nbsp;    Grayscale Mask (Edit if needed):<br/>
        {% for image_path in image_paths %}
        <div class="image-item">
            <img src="{{ image_path }}" alt="Image">
            <div>
                <label>
                    <input type="radio" name="top_image" value="{{ image_path }}" required> Top
                </label>
                <label>
                    <input type="radio" name="mask_image" value="{{ image_path }}" required> Mask
                </label>
                <label>
                    <input type="radio" name="bottom_image" value="{{ image_path }}" required> Bottom
                </label>
            </div>
        </div>
    
        <img src="{{ url_for('static', filename='images/' + image_path.split('/')[-1]) }}" width="200px">
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
 
        <img src="{{ url_for('static', filename='masks/grayscale_mask.png') }}" width="200px">
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
    
    </form>

</body>
</html>
<!DOCTYPE html>
<html>

<head>
    <title>Display Images</title>
    <style>
        body {
            background-color: cadetblue;
        }

        h1 {
            color: orange;
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            padding: 20px;
        }

        .image-item {
            margin: 10px;
            text-align: center;
        }

        .image-item img {
            width: 200px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .image-item label {
            display: block;
            margin-top: 5px;
        }

        button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }
    </style>
</head>

<body  style="background-color: rgb(156, 23, 23);">
    <h1 style="color: orange;">Randomly_ Selected Images</h1>

    <form action="/blend_images" method="post">

        <div class="container">
            {% for image_path in image_paths %}
            <div class="image-item">
                <img src="{{ image_path }}" alt="Image">
                <div>
                    <label>
                        <input type="radio" name="top_image" value="{{ image_path }}" required> Top
                    </label>
                    <label>
                        <input type="radio" name="mask_image" value="{{ image_path }}" required> Mask
                    </label>
                    <label>
                        <input type="radio" name="bottom_image" value="{{ image_path }}" required> Bottom
                    </label>
                </div>
            </div>
            {% endfor %}
        </div>
            <input type="hidden" name="image_paths" value="{{ image_path }}">

            <input type="hidden" name="mask_path" value="{{ mask_path }}">
            <!--input type="hidden" name="opacity" value="{{ opacity }}"-->
            <label for="opacity">Opacity (between 0 and 1):</label>
            <input type="text" id="opacity" name="opacity" value="{{ opacity }}">
            <button type="submit">Edit Mask and Blend Again</button>
    </form>
    <!-- return home -->
    <form action="/" method="get">
        <button type="submit">Home</button>
    </form>
   
</body>

</html><!DOCTYPE html>
<html>
<head>
    <title>Display Images</title>
</head>
<body  style="background-color: rgb(156, 23, 23);">
    <h1 style="color: orange;" >Randomly: Selected Images</h1>

    <form action="/edit_mask" method="post">
        {% for image_path in image_paths %}
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
        <input type="hidden" name="opacity" value="{{ opacity }}">
        <button type="submit">Edit Mask and Blend Again</button>
    </form>
        <!-- return home -->
        <form action="/" method="get">
            <button type="submit">Home</button>
        </form>
    <form action="/blend_images" method="post">
      
        <label for="opacity">Opacity (between 0 and 1):</label>
        <input type="text" id="opacity" name="opacity" value="{{ opacity }}">
      
        <button type="submit">Blend Images with Mask</button>&nbsp;&nbsp;    Grayscale Mask (Edit if needed):<br/>
        {% for image_path in image_paths %}
        <div class="image-item">
            <img src="{{ image_path }}" alt="Image">
            <div>
                <label>
                    <input type="radio" name="top_image" value="{{ image_path }}" required> Top
                </label>
                <label>
                    <input type="radio" name="mask_image" value="{{ image_path }}" required> Mask
                </label>
                <label>
                    <input type="radio" name="bottom_image" value="{{ image_path }}" required> Bottom
                </label>
            </div>
        </div>
    
        <img src="{{ url_for('static', filename='images/' + image_path.split('/')[-1]) }}" width="200px">
        <input type="hidden" name="image_paths" value="{{ image_path }}">
        {% endfor %}
 
        <img src="{{ url_for('static', filename='masks/grayscale_mask.png') }}" width="200px">
        <input type="hidden" name="mask_path" value="{{ mask_path }}">
    
    </form>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Select Images</title>
</head>
<body>
    <h1>Select Images to Blend</h1>
    <form method="POST" action="{{ url_for('get_images') }}">
        {% for image_path in image_paths %}
            <div>
                <label>
                    <input type="radio" name="role_{{ loop.index }}" value="top" required> Top
                </label>
                <label>
                    <input type="radio" name="role_{{ loop.index }}" value="mask"> Mask
                </label>
                <label>
                    <input type="radio" name="role_{{ loop.index }}" value="bottom"> Bottom
                </label>
                <input type="hidden" name="image_{{ loop.index }}" value="{{ image_path }}">
                <img src="{{ image_path }}" alt="Image" style="width: 200px;">
            </div>
        {% endfor %}
        <button type="submit">Blend Images</button>
        <button type="submit" name="randomize" value="true">Blend Random Images</button>
    </form>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display Archived Resources</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='dark.css') }}">
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Merriweather Sans', sans-serif;
        }
        .container {
            width: 80%;
            margin: 0 auto;
            padding-top: 20px;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .image-item {
            margin: 10px;
            text-align: center;
        }
        .image-item img {
            max-width: 200px;
            max-height: 300px;
            display: block;
            margin-bottom: 10px;
            border: 2px solid #444;
            border-radius: 8px;
        }
        .image-item input[type="checkbox"] {
            margin-top: 5px;
        }
        .submit-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #444;
            color: #e0e0e0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .submit-btn:hover {
            background-color: #666;
        }
        .refresh-button {
            display: inline-block;
            margin-bottom: 10px;
            padding: 10px 20px;
            background-color: #444;
            color: #e0e0e0;
            text-decoration: none;
            border-radius: 5px;
        }
        .refresh-button:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Archived Resources</h1>
        <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>
        <form action="{{ url_for('copy_images') }}" method="POST">
            <div class="image-container">
                {% for image_path in image_paths %}
                    <div class="image-item">
                        <img src="{{ url_for('static', filename=image_path.split('static/')[1]) }}" alt="Image">
                        <input type="checkbox" name="selected_images" value="{{ image_path }}">
                    </div>
                {% endfor %}
            </div>
            <button class="sticky" type="submit" class="submit-btn">Submit Selected Images</button>
        </form>
    </div>
</body>
</html>
{% extends 'base.html' %}

{% block title %}Home{% endblock %}

{% block content %}
<style>textarea {
    width: 96%;
    height: 700px;
    color: lightgreen; /* Light green for code text */
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto; /* Enable horizontal scroll for long code lines */
    /* white-space: pre-wrap; */
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: break-all;
    font-size: 15px;

}
</style>
    <h1>Edit Text File - {{ filename }}</h1>
    -- edit.html --
    
    <form action="{{ url_for('edit', filename=filename) }}" method="post">
        <label for="text">Text:</label><br>
        <textarea id="text" name="text" required>{{ text }}</textarea><br><br>
        <button type="submit">Save Changes</button>
    </form>

    
    {% endblock %}
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit {{ filename }}</title>
</head>
<body>
    <h1>Edit {{ filename }}</h1>
    <form method="post">
        <textarea name="content" style="width: 100%; height: 400px;">{{ content }}</textarea><br>
        <button type="submit">Save</button>
    </form>

    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    <ul>
        {% for category, message in messages %}
        <li class="{{ category }}">{{ message }}</li>
        {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}
</body>
</html>
<!-- edit_post.html -->
{% extends 'base.html' %}

{% block title %}ID:{{post[0]}}&nabla;&nabla; | &nabla;&nabla; Edit - Post - {{ post[1] }}{% endblock %}

{% block content %}

<style>
    textarea {
        width: 100% !important;
        height: 400px !important;
        margin: 10px 0;
        padding: 10px;
        font-size: 16px;
    }
</style>


<h1>Edit Post- edit_post.html</h1>
<form method="POST" enctype="multipart/form-data">
    <label>Title</label><br>
    <input type="text" name="title" value="{{ post[1] }}" required><br><br>

    <label>Content</label><br>
    <textarea name="content" rows="50" required>{{ post[2] }}</textarea><br><br>

    <label>Image</label><br>
    <input type="file" name="image"><br><br>
    {% if post[3] %}
    <img src="data:image/png;base64,{{ post[3] }}" alt="{{ post[1] }}" style="max-width: 400px;"><br><br>
    {% endif %}

    <label for="video">Upload Video</label>
    <input type="file" id="video" name="video" accept="video/*">
    {% if post[4] %}
    <video width="320" height="240" controls>
        <source src="{{ url_for('static', filename='videos/' + post[4]) }}" type="video/mp4" />
        Your browser does not support the video tag.
    </video>
    {% endif %}
<br/>
    <button type="submit">Update</button>
</form>
{% endblock %}{% extends 'base.html' %}

{% block title %}Home{% endblock %}

{% block content %}
    <h1>Text File Editor</h1>
    <h2>Existing Text Files-click filenames to edit</h2>
    <ul>
        {% for file in files %}
            <li>
                <a href="{{ url_for('edit', filename=file) }}">{{ file }}</a>&nbsp;&nbsp; | &nbsp;&nbsp;
                <a style="color:red;" href="{{ url_for('delete', filename=file) }}">Delete</a>
            </li>
   
        {% endfor %}
    </ul>
    {% endblock %}
   
</body>
</html>
```<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Detection and Overlay</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .image-display {
            text-align: center;
            margin-top: 20px;
        }
        .image-display img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin-top: 10px;
        }
        .upload-form {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body style="background-color: cadetblue;">
    <h1 style="color: orange;">Face Detection and Image Overlay</h1>
    <!-- link index/home -->
<a href="{{ url_for('index') }}" class="refresh-button">Home</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <div class="container">
        <p>Upload an image to detect the face, apply feathering, and overlay it onto a random background.</p>

        <div class="upload-form">
            <form action="/face_detect" method="post" enctype="multipart/form-data">
                <input type="file" name="file">
                <button type="submit">Upload and Process</button>
            </form>
        </div>

        {% if feathered_image %}
        <div class="image-display">
            <h2>Feathered Face Image</h2>
            <img src="{{ url_for('static', filename=feathered_image.split('static/')[1]) }}" alt="Feathered Face Image">
        </div>
        {% endif %}

        {% if composite_image %}
        <div class="image-display">
            <h2>Composite Image</h2>
            <img src="{{ url_for('static', filename=composite_image.split('static/')[1]) }}" alt="Composite Image">
        </div>
        {% endif %}
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Gallery</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #2c3e50;
            color: #ecf0f1;
            text-align: center;
        }
        .gallery {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .gallery-item {
            margin: 20px;
        }
        .gallery-item img {
            max-width: 300px;
            max-height: 200px;
            display: block;
            margin: 10px auto;
        }
        .sp {
            display: block;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            max-width: 300px;
            white-space: pre-wrap;
            word-wrap: break-word;
            
        }
        a {
            color: #3498db;
            font-size: 3em;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <h1>Image Gallery</h1>
    <a href="{{ url_for('home2') }}">Home2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="{{ url_for('index') }}">Home</a>
    <div class="gallery">
        {% for item in gallery_data %}
        <div class="gallery-item">
            <h3 class='sp' >Directory: {{ item.directory }}</h3>
            {% for image in item.images %}
            <img src="{{ image }}" alt="Image">
            <p class='sp'>{{ image }}</p>
            {% endfor %}
        </div>
        {% endfor %}
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Download YouTube Video and Extract Images</title>
</head>
<body  style="background-color: rgb(156, 23, 23);">

    <h1  style="color: orange;" >Download YouTube Video and Extract Images</h1>
    <!-- link to home -->
    <a href="/">Index</a><br/><br/>
    https://www.youtube.com/shorts/ZKD0t4kt0MA
    <form method="POST">
        <label for="url">YouTube URL:</label>
        <input type="text" id="url" name="url" placeholder="Enter YouTube URL" required>
        <button type="submit">Download and Extract Images</button>
    </form>
</body>
</html>
{% extends 'base.html' %}

{% block title %}Home{% endblock %}

{% block content %}
<h2>Home</h2>
<ul>
    {% for post in posts %}
    <li>
        <h3>{{ post[1] }}</h3>
        <br/>
        {% if post[3] %}
        <img src="data:image/png;base64,{{ post[3] }}" alt="image.jpg">
        {% endif %}
        {% if post[4] %}
        <video width="320" height="240" controls>
            <source src="{{ url_for('static', filename='videos/' ~ post[4]) }}" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        {% endif %}
        <p>ID:{{post[0]}}&nbsp;&nbsp;&nbsp;  {{ post[2][:200] }}...</p>
        <a href="{{ url_for('show_post', post_id=post[0]) }}">Read more</a> &nbsp;&nbsp; | &nbsp;&nbsp; <a href="{{ url_for('edit_post', post_id=post[0]) }}">EDIT</a>

        <hr style="margin-top: 20px;"/>
    </li>
    {% endfor %}
</ul>
{% endblock %}

{% extends 'base.html' %}

{% block title %}Home{% endblock %}

{% block content %}
<h2>Home</h2>
<ul>
    {% for post in posts %}
    <li>
        <h3>{{ post[1] }}</h3>
        <br/>
        {% if post[3] %}
        <img src="data:image/png;base64,{{ post[3] }}" alt="image.jpg">
        {% endif %}
        {% if post[4] %}
        <video width="320" height="240" controls>
            <source src="{{ url_for('static', filename='videos/' ~ post[4]) }}" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        {% endif %}
        <p>ID:{{post[0]}}&nbsp;&nbsp;&nbsp;  {{ post[2][:200] }}...</p>
        <a href="{{ url_for('show_post', post_id=post[0]) }}">Read more</a> &nbsp;&nbsp; | &nbsp;&nbsp; <a href="{{ url_for('edit_post', post_id=post[0]) }}">EDIT</a>

        <hr style="margin-top: 20px;"/>
    </li>
    {% endfor %}
</ul>
{% endblock %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template Editor</title>
</head>
<body>
    <h1>Edit HTML Templates</h1>
    <ul>
        {% for file in template_files %}
        <li><a href="{{ url_for('edit_template', filename=file) }}">{{ file }}</a></li>
        {% endfor %}
    </ul>

    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    <ul>
        {% for category, message in messages %}
        <li class="{{ category }}">{{ message }}</li>
        {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}
</body>
</html>
<!-- templates/index.html -->
<!DOCTYPE html>
<html>

<head>
    <title>Edit a Text File</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 1%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-image: url('../static/assets/01-back.jpg');
            background-repeat: repeat-y;
            background-size: cover;
            /* Use 'cover' to make the image cover the entire body */
            background-position: top;
        }

        .wrapper {
            display: flex;
            flex-direction: column;
            background-color: rgba(255, 255, 255, 0.25);
            align-items: center;
            justify-content: center;
            min-height: 90vh;
        }

        .header {
            width: 100%;
            padding: 20px;
            text-align: center;
        }


        h1 {
            color: #ffffff;
            font-size: 3vw;
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
        }

        label {
            color: #ffffff;
            font-size: 1.5vw;
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
        }

        form {
            color: #ffffff;
            font-size: 1.5vw;
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
        }

        .columns {
            display: flex;
            width: 95%;
            margin-top: 20px;
        }

        .column {
            padding: 20px;
            box-sizing: border-box;
        }

        .column.left {
            width: 15%;
            border: 1px solid #000;
            text-align: center;
        }

        .column.right {
            margin: 0 auto;
            /* Center horizontally */
            width: 80%;
            border: 1px solid #000;
            text-align: center;
            /* Center video vertically */
        }

        .column.right video {
            max-width: 100%;
            height: auto;
        }

        .note {
            color: red;
            font-size: 24px;
        }

        textarea {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;

            width: 100%;
        }

        #logo {
            position: absolute;
            /* Position the logo absolutely */
            top: 5vw;
            /* Adjust the top distance as needed */
            left: 6vw;
            /* Adjust the left distance as needed */
            max-width: 10vw;
            /* Set a maximum width for the logo */
            max-height: 15vw;
            /* Set a maximum height for the logo */
        }

        #logo2 {
            position: absolute;
            /* Position the logo absolutely */
            top: 22.5vw;
            /* Adjust the top distance as needed */
            left: 6vw;
            /* Adjust the left distance as needed */
            max-width: 10vw;
            /* Set a maximum width for the logo */
            max-height: 15vw;
            /* Set a maximum height for the logo */
        }

        .overlaylogo {
            position: absolute;
            /* Position the logo absolutely */
            top: 6.4vw;
            /* Adjust the top distance as needed */
            left: 7.7vw;
            /* Adjust the left distance as needed */
            max-width: 15w;
            /* Set a maximum width for the logo */
            max-height: 10vw;
            /* Set a maximum height for the logo */
        }
        p {
            color: #ffffff;
            font-size: 1.5vw;
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
        }
    </style>
    <div class="wrapper">
        <div class="columns">
            <div class="column left">
                <h2>File Search and Edit</h2>

                <a href="{{ url_for('view_text') }}"><img id="logo" src="../static/assets/search.png"
                        alt="logo" />
                </a><br />

                <a href="{{ url_for('indexapp') }}"><img id="logo2" src="../static/assets/channels4_profile.png" alt="logo" /> </a>
                <a href="/"><img class="overlaylogo" src={{logo}} alt="logo" /> </a>

            </div>
            <div class="column right">
                <a href="{{ url_for('view_text') }}"><button>Create New File</button></a>
                <h2>Edit File - {{ filename }}</h2>

                <br />

                <h1>File Search and/or Edit</h1>
                <form method="POST" action="{{ url_for('indexapp') }}">
                    <label for="search_term">Search Term:</label>
                    <input type="text" name="search_term" id="search_term" required>
                    <button type="submit">Search</button>
                </form>

                {% if files %}
                <h2>Matching Files:</h2>
                <form method="GET" action="{{ url_for('edit_files', filename='') }}">
                    <label for="file_select">Select File:</label>
                    <select name="filename" id="file_select">
                        {% for file in files %}
                        <option value="{{ file }}">{{ file }}</option>
                        {% endfor %}
                    </select>
                    <button type="submit">Edit Selected File</button>
                </form>
                {% endif %}
                <br /><br />
                <form method="POST" action="{{ url_for('new_snippet') }}">
                    <label for="snippet_content">Snippet Content:</label><br>
                    <textarea id="snippet_content" name="content" rows="10" cols="50"></textarea><br>
                    <input type="submit" value="Save">
                </form>
            </div>
        </div class="header">
        <p>Search for a file by entering a search term below. Then select a file from the list of matching files and
            click the "Edit Selected File" button.</p>
        <p>Once you have selected a file, you can edit the file content in the text area below. When you are done
            editing, click the "Save Changes" button to save the changes to the file.
            Click the "Back to Search" button to return to the search page.</p>
    </div>
    </div>
    </div>
    < </div>
        </body>

</html><!-- templates/index_y.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Suggestions</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 1%;
            height: 100%;
            font-family: Arial, sans-serif;
        }

        body {
            background-color: black;
            background-image: url('../static/assets/MemMaker_background.png');
            background-repeat: repeat-y;
            background-size: cover;
            /* Use 'cover' to make the image cover the entire body */
            background-position: top;
            color: rgb(61, 195, 12);
        }

        video {
            margin: 10px, auto;
            width: 250px;
            height: auto;
        }

        .wrapper {
            display: flex;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
            border: 1px solid darkgray;
        }

        .columns {
            display: flex;
            width: 100%;
            margin-top: 10px;
        }

        .column {
            padding: 5px;
            box-sizing: border-box;
        }

        .column.left {
            width: 50%;
            border: 1px solid #3b3232;
        }

        .column.right {
            margin: 0 auto;
            /* Center horizontally */
            width: 50%;
            /* Adjusted width to make space for wrapped text */
            border: 1px solid #3b3232;
            text-align: left;
            font-size: 20px;
            /* Allow text wrapping */
            word-wrap: break-word;
            white-space: pre-wrap;
        }


        .column.right video {
            max-width: 100%;
            height: auto;
        }

        .footer {
            width: 98%;
            padding: 20px;
            background-color: #333;
            color: white;
            text-align: center;
            position: relative;
            /* Make it relative to the container */
            bottom: 0;
            /* Push it to the bottom */
        }
        #code {
            font-size: 18px;
            font-family: monospace;
        }
        .notes {
            margin-top: 0px auto;
            font-size: 18px;
            color: rgb(105, 178, 230);
        }
        pre {
            white-space: pre-wrap;
        }
        .sticky {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: #760909;
            
        }
        .header {
            display: flex;
            align-items: left;
            margin: 0 auto;
            width: 98%;
            padding: 5px;
            text-align: center;
            background-color: #760909;
            color: rgb(238, 232, 201);
            padding: 10px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin-left: auto;
            margin-right: auto; 
       }
        .header h2 {
            margin-left: 20px;
        }
        .header button {
            margin-left: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            height: 32px;
            font-size: 16px;
            transition: background-color 0.3s ease;
            width: 200px;
        }
        .header button:hover {
            background-color: #45a049;
            height: 36px;
        }
        #search_input {
            height: 30px;
            width: 300px;
            font-size: 16px;
            border: 1px solid #f8e4c4;
            border-radius: 4px;
            margin-left: 20px;
        }
       
    </style>
<script>
    // Function to find and highlight the search string
    function findString(str) {
        if (parseInt(navigator.appVersion) < 4) return;
        
        // Check if find method is supported
        if (window.find) {
            // Find the search string
            var strFound = window.find(str);
            if (!strFound) {
                // If not found, try to find from the beginning
                window.find(str, 0, 1);
            }
            if (strFound) {
                // Highlight the found text
                var range = window.getSelection().getRangeAt(0);
                var span = document.createElement('span');
                span.style.backgroundColor = 'yellow';
                range.surroundContents(span);
            }
        } else if (navigator.appName.indexOf("Microsoft") != -1) {
            // Handle Microsoft browsers
            // Not implemented for brevity
        } else if (navigator.appName == "Opera") {
            // Handle Opera browsers
            alert("Opera browsers not supported, sorry...");
            return;
        }

        // If not found, show alert
        if (!strFound) alert("String '" + str + "' not found!");
    }

    // Function to move cursor to next occurrence of search input
    function moveToNextOccurrence() {
        var search_str = document.getElementById("search_input").value;
        findString(search_str);
    }
</script>

</head>

<body>
    <div class="wrapper">
        <div class="header sticky">
            <h2>Code Suggestions: text_completion/templates/index_code.html  |</h2>&nbsp;&nbsp;&nbsp;&nbsp;
            <button id="search_submit" onclick="moveToNextOccurrence()">Find Next</button>
<input type="text" id="search_input"><a href="/view_functions" target="_blank">view_functions</a>
        </div>
        <div class="columns">
            <div class="column left">
<pre class="notes">
{{functions}}
</pre>
                <a style="font-size: 24px;
                color: antiquewhite;" href="/readlog" target="_blank">readlog</a>
                <form id="codeForm">
                    <label for="code">Enter your code:</label><br>
                    <textarea id="code" name="code" rows="10" cols="55"></textarea><br>
                    <button type="button" onclick="submitForm()">Generate Suggestions</button>
                </form>
            </div>
            <div class="column right">
                <div id="suggestions">
                    <!-- Suggestions will be displayed here -->
                </div>

                <script>
                    function submitForm() {
                        var code = document.getElementById('code').value;
                        var formData = new FormData();
                        formData.append('code', code);

                        fetch('/save', {
                            method: 'POST',
                            body: formData,
                        })
                            .then(response => response.json())
                            .then(data => {
                                displaySuggestions(data.suggestions);
                            })
                            .catch((error) => {
                                console.error('Error:', error);
                            });
                    }

                    function displaySuggestions(suggestions) {
                        var suggestionsDiv = document.getElementById('suggestions');
                        suggestionsDiv.innerHTML = '<h2>Suggestions:</h2>';
                        suggestions.forEach(function (suggestion) {
                            suggestionsDiv.innerHTML += '<p>' + suggestion + '</p>';
                        });
                    }
                </script>
            </div>
        </div>
    </div>
    <footer class="footer">
        <p>Code Suggestions</p>
        <p>Append suggestions to the completion source</p>
        <!-- Footer content with textarea -->
        <textarea id="userCode" placeholder="Your message here" rows="25" cols="120"></textarea>
        <button onclick="saveCode()">Submit</button>
        <script>    function saveCode() {
            var code = document.getElementById('userCode').value;
        
            fetch('/save_code', {
                method: 'POST',
                body: code, // Send the code directly without JSON.stringify
            })
                .then(response => {
                    if (response.ok) {
                        alert('Code saved successfully!');
                    } else {
                        alert('Failed to save code.');
                    }
                })
                .catch((error) => {
                    console.error('Error:', error);
                    alert('Failed to save code.');
                });
        }
        </script>        
    </footer>
    

</body>

</html><!DOCTYPE html>
<html>

<head>
    <title>Image Blending</title>

    <style>
        body {
            background-color: #2C2C2C;
            color: white;
            font-family: Arial, sans-serif;
        }

        .refresh-button {
            display: inline-block;
            padding: 5px 5px 5px 5px;
            margin: 10px 10px 10px 10px;

            font-size: 2em;
            background-color: orange;
            color: rgb(0, 0, 0);
            text-decoration: none;
            border-radius: 5px;
            margin: 1px;
        }

        .refresh-button2 {
            display: inline-block;
            padding: 5px 5px 5px 5px;
            margin: 10px 10px 10px 10px;

            font-size: 2em;
            background-color: rgb(255, 225, 0);
            color: rgb(0, 0, 0);
            text-decoration: none;
            border-radius: 5px;
            margin: 1px;
        }

        .refresh-button:hover {
            background-color: orange;
        }

        .sticky {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            background-color: orange;
            padding: 10px 0;
            z-index: 1000;
        }
    </style>
</head>

<body style="background-color: rgb(156, 23, 23);">
    <center>
        <h1 style="color: orange;">FlaskArchitect's Image Blending with Grayscale Mask</h1>

        <a href="{{ url_for('refresh_images') }}" class="refresh-button">Refresh
            Images</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('display_resources') }}" class="refresh-button">Display Resource
            Images</a><br /><br />
        <a href="{{ url_for('select_images') }}" class="refresh-button">Select Images to
            Blend</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('index_upload') }}" class="refresh-button">Upload a Specific Image</a><br /><br />
        <a href="{{ url_for('get_video_images') }}" class="refresh-button">Get Images via YouTube
            Videos</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('face_detect') }}" class="refresh-button">Image For Face Detection</a> <br /><br />
        <a href="{{ url_for('refresh_video') }}" class="refresh-button">Make Video</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('add_text') }}" class="refresh-button">Add Text</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('upload_image') }}" class="refresh-button">Add a Torn Edge
            Effect</a> <br /><br />

        <a href="{{ url_for('clean_archives') }}" class="refresh-button">Clean
            Archives</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('clean_storage') }}" class="refresh-button">Clean Movie
            Sources</a><br /> <br />
        <a href="{{ url_for('select_mask_image') }}" class="refresh-button">Mask
            -Choice-</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <a href="{{ url_for('create_video') }}" class="refresh-button">Create Seamless Video</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('mk_mask') }}" class="refresh-button">Custom Mask</a> <br /><br />
        <a href="{{ url_for('home2') }}" class="refresh-button2">Text/Search/Notes</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="{{ url_for('rorschach') }}" class="refresh-button2">Create Rorschach</a><br /> <br /><br /> <br />
        <hr><br /> <br />
        <form action="/get_images" method="post">
            <button type="submit">Get Three Random Images</button>&nbsp;&nbsp; | &nbsp;&nbsp;
            <a style="color:yellow;" href=" {{ url_for('about') }}">About this Application</a>
        </form><br /> <br />


        <!--show images in store-->

        <!--h2>Stored Images</h2>
        <form action="/display_images" method="post">
            {% for image_path in image_paths %}
            &nbsp;<img src="{{ url_for('static', filename='archived-store/' + image_path.split('/')[-1]) }}"
                width="256px" height="384">

            {% endfor %}
        </form-->
        <h2>Recently Created Videos</h2><br /> <br />

        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP2.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP0.mp4" type="video/mp4">
        </video><br /><br />
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/final_flipbook.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP1.mp4" type="video/mp4">

        </video>
    </center>
</body>

</html><!DOCTYPE html>
<html>
<head>
    <title>Image Blending</title>
</head>
<body style="background-color: cadetblue;">
    <h1 style="color: orange;">FlaskArchitect's Image Blending with Grayscale Mask</h1>
    <form action="/get_images" method="post">
        <button type="submit">Get Three Random Images</button>
    </form>&nbsp;&nbsp;|&nbsp;&nbsp;<form action="/select_mask_image" method="post">
        <button type="submit">Special Mask -Choice-</button>
    </form>
    <!--show images in store-->
   
    <h2>Stored Images</h2>
    <form action="/display_images" method="post">
        {% for image_path in image_paths %}
        <img src="{{ url_for('static', filename='store/' + image_path.split('/')[-1]) }}" width="200px">

        {% endfor %}

</body>
</html>
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Upload new File</title>
</head>
<body>
    <h1>Upload new File</h1>
    <form method=post enctype=multipart/form-data action="{{ url_for('upload_file') }}">
        <input type=file name=file>
        <input type=submit value=Upload>
    </form>

</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Choose Mask Type</title>
</head>
<body>
    <h1>Choose Mask Type</h1>
    <form action="{{ url_for('choose_mask') }}" method="post">
        <input type="hidden" name="image_paths" value="{{ image_paths }}">
        <label for="mask_type">Select Mask Type:</label>
        <select name="mask_type" id="mask_type">
            <option value="grayscale">Grayscale</option>
            <option value="binary">Binary</option>
        </select>
        <button type="submit">Submit</button>
    </form>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Custom Mask</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        a {
            text-decoration: none;
            color: #007bff;
        }
        a:hover {
            text-decoration: underline;
        }
        form {
            margin-top: 20px;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        input {
            padding: 5px;
            margin-bottom: 10px;
        }
        input[type="submit"] {
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        input[type="number"] {
            width: 25%;
            font-size: 2em;
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            cursor: pointer;
        }       
        input[type="submit"]:hover {
            background-color: #0056b3;
        }
        a {
            display: inline-block;
            margin-top: 20px;
            font-size: 2.25em;
        
        }
    p {
        font-size: 1.5em;
    }
   label {
        font-size: 1em;
    }
   img {
        width: 250px;
        height: auto;
        display: block;
        border: 1px solid lightgray;
 
    }
    h2 {
        color: #333;
    }
    .separator {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }
    span {
        font-size: 1em;
    }
    pre {
        font-size: 1.5em;
        color: navy;
    }
   
    </style>

</head>
<body>
    <h1>Create Custom Mask</h1>
    <a href="/">Back to Home</a>
    <p>Enter the following details to create a custom mask:</p>
    <pre>filename mask_0_0_120_20_0.jpg details:
    mask_0_0 is position _120 is diameter _20 is the feather _0 is the aspect .jpg </pre>
    <h2>Mask Details</h2>
    <form action="/create_mask" method="post">
        <label for="x">Position X:</label>
        <input type="number" id="x" name="x" value="0"><br><br>

        <label for="y">Position Y:</label>
        <input type="number" id="y" name="y" value="0"><br><br>

        <label for="size">Size:</label>
        <input type="number" id="size" name="size" value="100"><br><br>

        <label for="feather">Feather:</label>
        <input type="number" id="feather" name="feather" value="30"><br><br>

        <label for="aspect">Aspect (0 = Circle, + Tall, - Wide):</label>
        <input type="number" id="aspect" name="aspect" value="0"><br><br>

        <input type="submit" value="Create Mask">
    </form>
    
<!-- Check if there are masks to display -->
{% if mask_data %}
    <!-- Container for side-by-side images -->
    <div class='separator'>
        <!-- Loop through each pair of mask and filename -->
        {% for mask, filename in mask_data %}
            <div style="text-align: center;">
                <h2>Mask Preview</h2>
                <img src="{{ mask }}" alt="Mask" style="width: 250px; height: auto;">
                
                <h2>Filename</h2>
                <pre>{{ filename[:-4] }}</pre>
            </div>
        {% endfor %}
    </div>
{% endif %}

<!-- Link to create another mask -->
<a href="{{ url_for('mk_mask') }}">Create Another Mask</a>



</body>
</html><!DOCTYPE html>
<html>

<head>
    <title>Image Blending</title>

    <style>
        body {
            background-color: #2C2C2C;
            color: white;
            font-family: Arial, sans-serif;
        }

        .refresh-button {
            display: inline-block;
            padding: 5px 5px 5px 5px;
            margin: 10px 10px 10px 10px;

            font-size: 2em;
            background-color: orange;
            color: rgb(0, 0, 0);
            text-decoration: none;
            border-radius: 5px;
            margin: 1px;
        }

        .refresh-button2 {
            display: inline-block;
            padding: 5px 5px 5px 5px;
            margin: 10px 10px 10px 10px;

            font-size: 2em;
            background-color: rgb(255, 225, 0);
            color: rgb(0, 0, 0);
            text-decoration: none;
            border-radius: 5px;
            margin: 1px;
        }

        .refresh-button:hover {
            background-color: orange;
        }

        .sticky {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            background-color: orange;
            padding: 10px 0;
            z-index: 1000;
        }
    </style>
</head>

<body style="background-color: rgb(156, 23, 23);">
    <center>
        <h1 style="color: orange;">FlaskArchitect's Image Blending with Grayscale Mask</h1>

        <a href="{{ url_for('refresh_images') }}" class="refresh-button">Refresh
            Images</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('display_resources') }}" class="refresh-button">Display Resource
            Images</a><br /><br />
        <a href="{{ url_for('select_images') }}" class="refresh-button">Select Images to
            Blend</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('index_upload') }}" class="refresh-button">Upload a Specific Image</a><br /><br />
        <a href="{{ url_for('get_video_images') }}" class="refresh-button">Get Images via YouTube
            Videos</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('face_detect') }}" class="refresh-button">Image For Face Detection</a> <br /><br />
        <a href="{{ url_for('refresh_video') }}" class="refresh-button">Make Video</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('add_text') }}" class="refresh-button">Add Text</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('upload_image') }}" class="refresh-button">Add a Torn Edge
            Effect</a> <br /><br />
        <a href="{{ url_for('uploadfile') }}" class="refresh-button"> Segment Image</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('clean_archives') }}" class="refresh-button">Clean
            Archives</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('clean_storage') }}" class="refresh-button">Clean Movie
            Sources</a><br /> <br />
        <a href="{{ url_for('select_mask_image') }}" class="refresh-button">Mask
            -Choice-</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('create_video') }}" class="refresh-button">Create Seamless
            Video</a-->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <a href="{{ url_for('mk_mask') }}" class="refresh-button">Custom Mask</a> <br /><br />
        <a href="{{ url_for('home2') }}" class="refresh-button2">Text/Search/Notes</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
            href="{{ url_for('rorschach') }}" class="refresh-button2">Create Rorschach</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        <a href="{{ url_for('outlinefile') }}" class="refresh-button2">Outline Image</a>
        <hr><br /> <br />
        <form action="/get_images" method="post">
            <button type="submit">Get Three Random Images</button>&nbsp;&nbsp; | &nbsp;&nbsp;
            <a style="color:yellow;" href=" {{ url_for('about') }}">About this Application</a>
        </form><br /> <br />


        <!--show images in store-->

        <!--h2>Stored Images</h2>
        <form action="/display_images" method="post">
            {% for image_path in image_paths %}
            &nbsp;<img src="{{ url_for('static', filename='archived-store/' + image_path.split('/')[-1]) }}"
                width="256px" height="384">

            {% endfor %}
        </form-->
        <h2>Recently Created Videos</h2><br /> <br />

        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP2X.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/verticalX.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP0X.mp4" type="video/mp4">
        </video><br /><br />
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/final_flipbookX.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/TEMP1X.mp4" type="video/mp4">
        </video>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/final_zoomX.mp4" type="video/mp4">
        </video><br /><br />
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/blendem_final_outputX.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/final_output_expX.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <video width="300" height="auto" controls>
            <source src="static/temp_exp/final_zoomyX.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


        <video width="300" height="auto" controls>
            <source src="static/temp_exp/all_videos.mp4" type="video/mp4">
        </video>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    </center>
</body>

</html>{% extends 'base.html' %}

{% block title %}Create New Post{% endblock %}

{% block content %}
<style>
    textarea {
        width: 100% !important;
        height: 400px !important;
        margin: 10px 0;
        padding: 10px;
        font-size: 16px;
    }
</style>
    <form action="{{ url_for('new_post') }}" method="post" enctype="multipart/form-data">
        <label for="title">Title</label>
        <input type="text" id="title" name="title" required>
        <br>
        <label for="content">Content</label>
        <textarea id="content" name="content" required></textarea>
        <br>
        <label for="video">Upload Video</label>
        <input type="file" id="video" name="video" accept="video/*">
        <br>
        <label for="image">Upload Image</label>
        <input type="file" id="image" name="image" accept="image/*">
        <br>
        <button type="submit">Create Post</button>
    </form>
{% endblock %}
How does a Python image mask work ?
ChatGPT
In Python, an image mask is used to specify which parts of an image should be visible or altered and which parts should be hidden or left unchanged. The mask is typically a binary image where one value (usually white or 255) represents the areas of interest, and the other value (usually black or 0) represents the areas to be ignored or hidden.

Here’s a general overview of how an image mask works:

Creation of the Mask:

The mask is usually a grayscale image of the same dimensions as the original image.
Each pixel in the mask has a value between 0 and 255. If the mask is binary, the values are either 0 (black) or 255 (white).
Applying the Mask:

When the mask is applied to an image, only the parts of the image corresponding to the white (or 255) areas in the mask are kept or modified.
The black (or 0) areas in the mask correspond to parts of the image that are either hidden, set to transparent, or left unchanged.
Common Use Cases:

Selective Editing: You can use masks to apply changes only to specific parts of an image. For instance, you might want to adjust the brightness only in a particular region.
Compositing: When combining multiple images, masks can control which parts of each image are visible.
Transparency: In some applications, masks are used to make certain parts of an image transparent.
Example Using OpenCV
Here’s an example that demonstrates how to apply a mask to an image using the cv2 library in Python:

python
Copy code
import cv2
import numpy as np

# Load the original image
image = cv2.imread('image.jpg')

# Create a mask (same dimensions as the image)
mask = np.zeros(image.shape[:2], dtype="uint8")

# Define a rectangular region in the mask (this region will be white)
cv2.rectangle(mask, (50, 50), (200, 200), 255, -1)

# Apply the mask to the image using bitwise AND
masked_image = cv2.bitwise_and(image, image, mask=mask)

# Display the original image, mask, and masked image
cv2.imshow("Original Image", image)
cv2.imshow("Mask", mask)
cv2.imshow("Masked Image", masked_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
Explanation:
Loading the Image: cv2.imread loads the image from the file.
Creating the Mask: np.zeros creates a black mask of the same size as the input image. The cv2.rectangle function then draws a white rectangle on the mask.
Applying the Mask: cv2.bitwise_and applies the mask to the original image. Only the area within the white rectangle remains visible in the output.
Displaying Results: Finally, the original image, the mask, and the masked image are displayed.
Use Case:
For example, in a science fiction scenario like yours, where an alien civilization is subtly influencing an AI model, masks could be metaphorically seen as the parts of the model the aliens choose to reveal their influence on, while other parts remain untouched or hidden from human developers.

Would you like to dive deeper into how masks could be used in a specific context?

I will choose two images foreground which has a face some where on it, and  a background image. I want to mask out the background of the top image and composite overlay it on the background. The face needs to have feathered edges and can be in the same position. Do you understand?
ChatGPT
Yes, I understand! You want to create a composite image where the foreground image (which contains a face) is overlaid onto a background image. The goal is to mask out the background of the foreground image, apply feathered edges to the face area, and then place this processed image onto the new background, maintaining the face's position.

Here's how you can achieve this in Python using OpenCV and NumPy:

Step-by-Step Breakdown
Load the Images: Load both the foreground (with the face) and background images.
Create a Mask for the Face: Use a binary mask to isolate the face area in the foreground image.
Apply Feathering: Smooth the edges of the mask (feathering) to blend the face seamlessly with the background.
Composite the Images: Overlay the feathered face onto the background.
Code Example
Here’s a Python script to accomplish this:

python
Copy code
import cv2
import numpy as np

# Load the foreground and background images
foreground = cv2.imread('foreground.jpg')
background = cv2.imread('background.jpg')

# Resize the background to match the foreground if necessary
background = cv2.resize(background, (foreground.shape[1], foreground.shape[0]))

# Step 1: Create a binary mask for the face region (this could be done manually or using face detection)
# For simplicity, we'll assume a circular mask around the face
mask = np.zeros(foreground.shape[:2], dtype="uint8")
center = (foreground.shape[1] // 2, foreground.shape[0] // 2)  # Assuming face is in the center
radius = 100  # Adjust as needed to cover the face
cv2.circle(mask, center, radius, 255, -1)

# Step 2: Feather the edges of the mask
mask = cv2.GaussianBlur(mask, (21, 21), 0)

# Step 3: Create the inverse mask for background blending
inverse_mask = cv2.bitwise_not(mask)

# Step 4: Apply the masks to the foreground and background
foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)

# Step 5: Combine the masked foreground and background
result = cv2.add(foreground_face, background_masked)

# Display the result
cv2.imshow("Foreground", foreground)
cv2.imshow("Background", background)
cv2.imshow("Masked Foreground", foreground_face)
cv2.imshow("Composite Image", result)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Optionally, save the result
cv2.imwrite('composite_image.jpg', result)
Explanation:
Loading the Images: cv2.imread loads both the foreground (with the face) and the background images.
Creating the Mask: We create a circular binary mask centered around the face area (assumed to be near the center of the image). You can adjust the radius and center as needed.
Feathering the Mask: The mask's edges are blurred using cv2.GaussianBlur to create a feathered effect, ensuring a smooth transition when the foreground is overlaid on the background.
Masking and Blending: The mask is applied to both the foreground and background images. The cv2.bitwise_and operation ensures that only the masked areas are used. The inverse_mask is applied to the background so that the area where the face will be placed is removed. Finally, cv2.add combines the masked foreground and background.
Displaying and Saving: The resulting composite image is displayed, and you can optionally save it to a file.
Additional Adjustments:
Face Detection: Instead of manually defining the mask, you could use a face detection algorithm (like Haar Cascades or DNN-based methods) to automatically detect the face and create a more precise mask.
Feathering Intensity: You can control the amount of feathering by adjusting the kernel size in the GaussianBlur function.
Positioning: If the face isn't centered, you can modify the center variable to the correct coordinates.
This approach should give you a smooth and visually appealing overlay of the face from the foreground image onto the background image. Would you like more details on any part of the process, such as face detection or mask creation?

The face needs to be detected it may be any size and in any location in the image 
ChatGPT
Memory updated
To handle a face that may be of any size and in any location within the image, you'll need to integrate face detection into the process before applying the mask and compositing the images. OpenCV’s pre-trained face detection models, such as Haar Cascades or DNN-based models, can be used for this purpose.

Here's how you can update the previous code to include face detection:

Updated Code with Face Detection
python
Copy code
import cv2
import numpy as np

# Load the foreground and background images
foreground = cv2.imread('foreground.jpg')
background = cv2.imread('background.jpg')

# Resize the background to match the foreground if necessary
background = cv2.resize(background, (foreground.shape[1], foreground.shape[0]))

# Step 1: Detect the face in the foreground image using Haar Cascades
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)
faces = face_cascade.detectMultiScale(gray_foreground, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

# Check if at least one face was detected
if len(faces) > 0:
    # Get the coordinates of the first detected face
    (x, y, w, h) = faces[0]

    # Step 2: Create a circular mask around the detected face
    mask = np.zeros(foreground.shape[:2], dtype="uint8")
    center = (x + w // 2, y + h // 2)
    radius = max(w, h) // 2  # Use half of the larger dimension for the radius
    cv2.circle(mask, center, radius, 255, -1)

    # Step 3: Feather the edges of the mask
    mask = cv2.GaussianBlur(mask, (21, 21), 0)

    # Step 4: Create the inverse mask for background blending
    inverse_mask = cv2.bitwise_not(mask)

    # Step 5: Apply the masks to the foreground and background
    foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
    background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)

    # Step 6: Combine the masked foreground and background
    result = cv2.add(foreground_face, background_masked)

    # Display the result
    cv2.imshow("Foreground", foreground)
    cv2.imshow("Background", background)
    cv2.imshow("Masked Foreground", foreground_face)
    cv2.imshow("Composite Image", result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    # Optionally, save the result
    cv2.imwrite('composite_image.jpg', result)

else:
    print("No face detected in the foreground image.")
How It Works:
Face Detection:

Haar Cascade Classifier: This part uses a pre-trained Haar Cascade classifier (haarcascade_frontalface_default.xml) to detect faces in the grayscale version of the foreground image.
Multi-Scale Detection: The detectMultiScale function detects the face(s) and returns their bounding boxes (x, y, width, height).
Bounding Box: The first detected face is used, and a circular mask is created based on its bounding box.
Mask Creation:

A circular mask is centered around the detected face. The radius of the circle is set to half of the larger dimension (width or height) of the detected face.
Feathering:

The mask's edges are blurred to create a feathered effect, ensuring smooth blending.
Mask Application:

The foreground image is masked to isolate the face, and the inverse mask is applied to the background image to prepare it for compositing.
Compositing:

The masked face from the foreground is overlaid onto the background, creating the final composite image.
Display and Save:

The resulting composite image is displayed, and optionally, it can be saved to a file.
Face Detection with DNN
If you need a more robust face detection, you can replace the Haar Cascade with a DNN-based approach using models like SSD or MTCNN. These models typically provide more accurate detections, especially in challenging conditions like varied lighting or complex backgrounds.

Would you like to explore that option or have any further adjustments in mind?

I don't want to show the results just save them to static/archived_images
ChatGPT
To save the results directly to a folder like static/archived_images without displaying them, you can modify the code accordingly. Here's how to do it:

Updated Code to Save Images
python
Copy code
import cv2
import numpy as np
import os

# Paths for foreground, background, and output directories
foreground_path = 'foreground.jpg'
background_path = 'background.jpg'
output_dir = 'static/archived_images'

# Ensure the output directory exists
os.makedirs(output_dir, exist_ok=True)

# Load the foreground and background images
foreground = cv2.imread(foreground_path)
background = cv2.imread(background_path)

# Resize the background to match the foreground if necessary
background = cv2.resize(background, (foreground.shape[1], foreground.shape[0]))

# Step 1: Detect the face in the foreground image using Haar Cascades
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)
faces = face_cascade.detectMultiScale(gray_foreground, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

# Check if at least one face was detected
if len(faces) > 0:
    # Get the coordinates of the first detected face
    (x, y, w, h) = faces[0]

    # Step 2: Create a circular mask around the detected face
    mask = np.zeros(foreground.shape[:2], dtype="uint8")
    center = (x + w // 2, y + h // 2)
    radius = max(w, h) // 2  # Use half of the larger dimension for the radius
    cv2.circle(mask, center, radius, 255, -1)

    # Step 3: Feather the edges of the mask
    mask = cv2.GaussianBlur(mask, (21, 21), 0)

    # Step 4: Create the inverse mask for background blending
    inverse_mask = cv2.bitwise_not(mask)

    # Step 5: Apply the masks to the foreground and background
    foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
    background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)

    # Step 6: Combine the masked foreground and background
    result = cv2.add(foreground_face, background_masked)

    # Save the result to the specified directory
    output_path = os.path.join(output_dir, 'composite_image.jpg')
    cv2.imwrite(output_path, result)

    print(f"Composite image saved to: {output_path}")

else:
    print("No face detected in the foreground image.")
Changes and Explanation:
Output Directory:

output_dir = 'static/archived_images': This is where the resulting image will be saved.
The os.makedirs(output_dir, exist_ok=True) ensures that the directory exists before attempting to save the image.
Saving the Result:

The cv2.imwrite(output_path, result) function saves the composite image to the specified output_dir.
The output path is created by joining the directory and file name using os.path.join.
Removing Display Code:

The original cv2.imshow and cv2.waitKey(0) lines are removed since the image is now saved directly.
Output
This code will save the resulting composite image as composite_image.jpg in the static/archived_images directory. The program will also print the path to the saved image as a confirmation.

If you want to save with different names or keep track of multiple images, you can modify the file name generation part. Would you like to see how to do that?

Yes and I would like a function: def overlay_face(top_image,bottom_image):  if no face is present continue to create a composite image. Maybe the top image will not have a face 
ChatGPT
Here's an updated version of the code with a function overlay_face that handles the overlay process. If no face is detected in the top_image, the function will still create a composite image without applying the mask.

Updated Code with overlay_face Function
python
Copy code
import cv2
import numpy as np
import os

def overlay_face(top_image, bottom_image, output_dir='static/archived_images'):
    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Load the top and bottom images
    foreground = cv2.imread(top_image)
    background = cv2.imread(bottom_image)

    # Resize the background to match the foreground if necessary
    background = cv2.resize(background, (foreground.shape[1], foreground.shape[0]))

    # Convert the foreground to grayscale for face detection
    gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)

    # Step 1: Detect the face in the top image using Haar Cascades
    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
    faces = face_cascade.detectMultiScale(gray_foreground, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    # Initialize the mask and inverse mask
    mask = np.zeros(foreground.shape[:2], dtype="uint8")
    inverse_mask = np.ones(foreground.shape[:2], dtype="uint8") * 255

    # If a face is detected, create the mask
    if len(faces) > 0:
        # Get the coordinates of the first detected face
        (x, y, w, h) = faces[0]

        # Create a circular mask around the detected face
        center = (x + w // 2, y + h // 2)
        radius = max(w, h) // 2  # Use half of the larger dimension for the radius
        cv2.circle(mask, center, radius, 255, -1)

        # Feather the edges of the mask
        mask = cv2.GaussianBlur(mask, (21, 21), 0)

        # Create the inverse mask for background blending
        inverse_mask = cv2.bitwise_not(mask)

    # Step 2: Apply the masks to the foreground and background
    foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
    background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)

    # Step 3: Combine the masked foreground and background
    result = cv2.add(foreground_face, background_masked)

    # Generate a unique output file name
    output_filename = f"composite_image_{os.path.basename(top_image).split('.')[0]}_on_{os.path.basename(bottom_image).split('.')[0]}.jpg"
    output_path = os.path.join(output_dir, output_filename)

    # Save the result to the specified directory
    cv2.imwrite(output_path, result)

    print(f"Composite image saved to: {output_path}")
    return output_path

# Example usage
# overlay_face('top_image.jpg', 'bottom_image.jpg')
Explanation:
Function Definition:

overlay_face(top_image, bottom_image, output_dir='static/archived_images'): This function takes the paths of the top_image (foreground) and bottom_image (background) as inputs, along with an optional output_dir parameter.
Directory Handling:

os.makedirs(output_dir, exist_ok=True) ensures the output directory exists.
Face Detection:

The function attempts to detect a face using Haar Cascades.
If a face is detected, it creates a circular mask around the face and feathers the edges.
Mask Application:

The function uses the created mask to blend the foreground face with the background. If no face is detected, the mask will not alter the image, and the entire top_image will be overlaid onto the bottom_image.
File Naming:

The output file name is generated based on the names of the input images for uniqueness, following the pattern composite_image_topImageName_on_bottomImageName.jpg.
The output_path is where the result will be saved.
Saving the Composite Image:

The result is saved using cv2.imwrite(output_path, result).
Return Value:

The function returns the path to the saved composite image.
Usage:
You can call the overlay_face function with the paths to your foreground (top_image) and background (bottom_image) images:
python
Copy code
overlay_face('top_image.jpg', 'bottom_image.jpg')
This function will handle cases where the face is present and where it isn't, ensuring that a composite image is always created and saved. If you want to customize the file names further or handle additional edge cases, just let me know!

I would like to resize allll images to the height of 768 and crop the center 512 so the images are 512x768. Most images are already that size. That will give me the center region of any images with a different aspect.
ChatGPT
Memory updated
Here's how you can modify the overlay_face function to resize all images to a height of 768 pixels and crop the center region to 512x768:

Updated Code
python
Copy code
import cv2
import numpy as np
import os

def resize_and_crop(image, target_height=768, target_width=512):
    """
    Resize the image to the target height and crop the center region to the target width.
    """
    # Calculate the scale factor to resize the image to the target height
    scale_factor = target_height / image.shape[0]
    new_width = int(image.shape[1] * scale_factor)
    
    # Resize the image
    resized_image = cv2.resize(image, (new_width, target_height))
    
    # Calculate the cropping coordinates to get the center region
    x_center = resized_image.shape[1] // 2
    x_start = x_center - target_width // 2
    x_end = x_center + target_width // 2
    
    # Crop the center 512x768 region
    cropped_image = resized_image[:, x_start:x_end]
    
    return cropped_image

def overlay_face(top_image, bottom_image, output_dir='static/archived_images'):
    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Load the top and bottom images
    foreground = cv2.imread(top_image)
    background = cv2.imread(bottom_image)

    # Resize and crop both images to 512x768
    foreground = resize_and_crop(foreground)
    background = resize_and_crop(background)

    # Convert the foreground to grayscale for face detection
    gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)

    # Step 1: Detect the face in the top image using Haar Cascades
    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
    faces = face_cascade.detectMultiScale(gray_foreground, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    # Initialize the mask and inverse mask
    mask = np.zeros(foreground.shape[:2], dtype="uint8")
    inverse_mask = np.ones(foreground.shape[:2], dtype="uint8") * 255

    # If a face is detected, create the mask
    if len(faces) > 0:
        # Get the coordinates of the first detected face
        (x, y, w, h) = faces[0]

        # Create a circular mask around the detected face
        center = (x + w // 2, y + h // 2)
        radius = max(w, h) // 2  # Use half of the larger dimension for the radius
        cv2.circle(mask, center, radius, 255, -1)

        # Feather the edges of the mask
        mask = cv2.GaussianBlur(mask, (21, 21), 0)

        # Create the inverse mask for background blending
        inverse_mask = cv2.bitwise_not(mask)

    # Step 2: Apply the masks to the foreground and background
    foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
    background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)

    # Step 3: Combine the masked foreground and background
    result = cv2.add(foreground_face, background_masked)

    # Generate a unique output file name
    output_filename = f"composite_image_{os.path.basename(top_image).split('.')[0]}_on_{os.path.basename(bottom_image).split('.')[0]}.jpg"
    output_path = os.path.join(output_dir, output_filename)

    # Save the result to the specified directory
    cv2.imwrite(output_path, result)

    print(f"Composite image saved to: {output_path}")
    return output_path

# Example usage
# overlay_face('top_image.jpg', 'bottom_image.jpg')
Explanation:
Resizing and Cropping:

resize_and_crop Function: This function resizes the image to a height of 768 pixels, maintaining the aspect ratio, and then crops the center region to a width of 512 pixels. This ensures that all images have the same dimensions of 512x768.
Usage in overlay_face:

Before processing, both the foreground and background images are resized and cropped using the resize_and_crop function. This standardizes the dimensions, ensuring consistent compositing.
Processing as Before:

The rest of the function remains unchanged, handling face detection, mask creation, and image compositing as discussed earlier.
Usage:
You can use the overlay_face function as before. The images will be resized and cropped to 512x768 pixels before any further processing, ensuring that all images conform to the desired aspect ratio and size.

Would you like any additional modifications or features?

I just love Python and you make it great fun to play with. Any suggestions?
ChatGPT
I'm so glad you're enjoying working with Python! It's a powerful and flexible language, and your enthusiasm really brings out its best.

Suggestions to Enhance Your Project:
Batch Processing:

If you're working with multiple images, consider writing a script that batch processes all images in a directory. This would save you time and automate the process of applying your overlay_face function to many pairs of images.
Add Logging:

You mentioned you like detailed logging. Adding logging to your overlay_face function would allow you to track each step of the process, especially when processing many images. You could use Python's built-in logging module to record detailed information like file names, processing times, and any issues encountered.
Command-Line Interface (CLI):

You might consider turning your script into a CLI tool using argparse. This would allow you to run your script with different options and parameters directly from the terminal, making it more versatile and easier to use for different tasks.
Advanced Face Detection:

For more sophisticated face detection, you could explore using a deep learning model like MTCNN or a pre-trained model from the dlib library. These methods can detect multiple faces and handle different angles and lighting conditions more robustly.
Add Configurable Parameters:

You can add flexibility by allowing users (or yourself) to adjust parameters like mask feathering, resizing dimensions, and detection thresholds via a configuration file or command-line arguments.
Version Control with Git:

If you're not already using version control, consider using Git to track changes in your project. It’s especially useful for experimenting with new features or changes, allowing you to easily revert if something doesn’t work out.
Create a GUI:

If you want to take this project to the next level, consider building a simple graphical user interface (GUI) using tkinter or PyQt. This could make your tool more user-friendly and accessible, even to those who aren't comfortable with the command line.
Performance Optimization:

As your project grows, performance might become an issue. You could look into optimizing image processing tasks using libraries like Numba for just-in-time compilation or multiprocessing to take advantage of multi-core CPUs.
Experiment with AI/ML Models:

Given your background and interest, you could experiment with integrating AI models that can enhance or transform the images in creative ways, such as style transfer or upscaling.
Document Your Work:

If you're planning to share your code or return to it later, consider documenting it well with comments, README files, and possibly even tutorials. This will make it easier to maintain and share with others.
Would you like to dive into any of these ideas further, or is there something specific you're curious about?

This will actually be used in a flask application. And videos made from the resulting images. It is a GitHub project now. I do like the dlib idea.  I am familiar with it do you think it will detect faces better?
ChatGPT
Memory updated
Using dlib for face detection is an excellent idea, especially if you're aiming for higher accuracy in your Flask application. dlib offers several advantages over traditional Haar Cascades:

Advantages of Using dlib:
Higher Accuracy:

dlib uses a Histogram of Oriented Gradients (HOG) feature-based method for detecting faces, which generally provides better accuracy than Haar Cascades, especially in detecting faces at different angles and under varied lighting conditions.
Multiple Faces Detection:

dlib is capable of detecting multiple faces in an image, which could be beneficial if your application needs to handle group photos or videos with more than one person.
Robustness:

The dlib face detector is less prone to false positives and can better handle variations in facial expressions, angles, and partial occlusions.
Pre-trained Models:

dlib also includes pre-trained models for facial landmarks, which can be used to detect specific features like eyes, nose, and mouth. This can be useful if you want to further refine your masking process around facial features.
Implementation Idea:
You could replace the Haar Cascade detection in your current script with dlib's face detector. Here's a basic idea of how you might integrate dlib:

python
Copy code
import dlib
import cv2
import numpy as np
import os

def overlay_face_with_dlib(top_image, bottom_image, output_dir='static/archived_images'):
    os.makedirs(output_dir, exist_ok=True)

    # Load the top and bottom images
    foreground = cv2.imread(top_image)
    background = cv2.imread(bottom_image)

    # Resize and crop both images to 512x768
    foreground = resize_and_crop(foreground)
    background = resize_and_crop(background)

    # Initialize dlib's face detector
    detector = dlib.get_frontal_face_detector()

    # Detect faces in the foreground image
    gray_foreground = cv2.cvtColor(foreground, cv2.COLOR_BGR2GRAY)
    faces = detector(gray_foreground)

    # Initialize the mask and inverse mask
    mask = np.zeros(foreground.shape[:2], dtype="uint8")
    inverse_mask = np.ones(foreground.shape[:2], dtype="uint8") * 255

    # If a face is detected, create the mask
    if len(faces) > 0:
        for face in faces:
            # Get the coordinates of the detected face
            x, y, w, h = face.left(), face.top(), face.width(), face.height()

            # Create a circular mask around the detected face
            center = (x + w // 2, y + h // 2)
            radius = max(w, h) // 2
            cv2.circle(mask, center, radius, 255, -1)

            # Feather the edges of the mask
            mask = cv2.GaussianBlur(mask, (21, 21), 0)

            # Create the inverse mask for background blending
            inverse_mask = cv2.bitwise_not(mask)

    # Apply the masks and combine the images as before
    foreground_face = cv2.bitwise_and(foreground, foreground, mask=mask)
    background_masked = cv2.bitwise_and(background, background, mask=inverse_mask)
    result = cv2.add(foreground_face, background_masked)

    # Save the result
    output_filename = f"composite_image_{os.path.basename(top_image).split('.')[0]}_on_{os.path.basename(bottom_image).split('.')[0]}.jpg"
    output_path = os.path.join(output_dir, output_filename)
    cv2.imwrite(output_path, result)

    print(f"Composite image saved to: {output_path}")
    return output_path
Benefits for Your Flask Application:
Better User Experience: With improved face detection, the results in your Flask application will be more consistent, providing higher-quality composites, especially in cases where the face is not perfectly centered or clearly visible.

Scalability: If your application scales to handle more complex scenarios or images with multiple people, dlib can handle it more gracefully.

Integration with Videos: Since your end goal involves creating videos from these images, having more precise face detection will ensure that the transitions and overlays in your videos look smoother and more professional.

Next Steps:
Experiment with dlib: Try integrating dlib into your current workflow and compare the results with the Haar Cascades method. You might want to test with a variety of images to see how dlib handles different cases.

Fine-Tuning: If you decide to go with dlib, you can further fine-tune the detection parameters, or even explore using dlib’s landmark detection for more precise masking around facial features.

Would you like to see the implementation of dlib integrated into your Flask application, or is there another aspect you'd like to explore?

I am using cv2 to get random images from YouTube videos from my channel. The videos are mine and I am making promo shorts from the composite images. So far it works fine, the finding of faces will be a neat feature.
ChatGPT
Memory updated
That sounds like a great project! Incorporating face detection with dlib will definitely add a layer of sophistication to your promotional shorts. Since you're already extracting random images from your videos, combining this with precise face detection and compositing will allow you to create visually appealing and targeted content.

Possible Enhancements for Your Project:
Automated Workflow:

You could automate the entire process of extracting images, detecting faces, and creating composites, all within your Flask application. This would allow you to generate new promo content with minimal effort.
Highlight Key Moments:

With face detection, you could focus on key moments in your videos where faces are prominent, ensuring that your promo shorts capture the most engaging parts of the video.
Dynamic Cropping:

If you're dealing with different video resolutions or aspect ratios, dynamic cropping based on face position could be useful. dlib’s face landmarks can help with this by allowing you to center the crop on the face or adjust it to include relevant features like the upper body.
Adding Text or Overlays:

You could enhance your promo shorts by adding dynamic text or graphic overlays based on the detected faces. For example, you could automatically add captions or tags near the detected faces, which could make the promo more engaging.
Batch Processing for Shorts:

Implement a batch processing feature that takes multiple videos, extracts key frames, applies face detection, creates composites, and then stitches these into a series of shorts. This could be a massive time-saver if you're looking to produce a lot of content.
Performance Optimization:

Depending on how many videos you’re processing, performance might become an issue. Using asynchronous processing or GPU acceleration (if available) could speed up the extraction and processing steps.
Next Steps:
Integrate dlib: Start by adding dlib to your current image extraction process and see how it enhances the quality of your composites.

Automate and Test: Automate the process end-to-end in your Flask app and test it with different video segments to ensure it handles various scenarios well.

Optimize for Performance: Consider performance optimization techniques to make sure your app runs efficiently, especially when processing longer videos or a larger number of images.

Would you like to dive into any of these enhancements, or are there other features you’re considering adding to your project?

It is some what automated it works when I sleep and don't need my computer. 
ChatGPT
Memory updated
That’s a smart setup! Running the process while you're not using the computer ensures you maximize efficiency without interrupting your workflow.

Further Optimization Ideas:
Scheduling Tasks:

If you're not already doing so, consider using a task scheduler like cron (on Linux) to automate when the script starts and stops. This way, the process can begin automatically during off-hours without any manual intervention.
Progress Logging:

Since the script runs unattended, detailed logging will be crucial. Ensure that logs capture progress, errors, and summaries of what was processed. You can review these logs in the morning to see how things went.
Resource Management:

To ensure your computer doesn't become overloaded, you might want to set resource limits (like CPU or memory usage) for the process. This can prevent the script from affecting other tasks if you happen to start using the computer while it's still running.
Email or Notification Alerts:

You could set up email notifications or desktop alerts to inform you when the process is complete, or if it encounters any critical errors. This way, you can quickly address any issues that arise overnight.
Daily Summaries:

Generate a daily summary report that gives you an overview of the images processed, faces detected, and any issues encountered. This can be emailed to you or saved in a designated folder.
Performance Monitoring:

If you're interested, you could implement basic performance monitoring to track how long each image processing step takes. This could help identify bottlenecks and optimize the script further over time.
It sounds like you're already on a great path with automation. Would you like help with any of these optimizations, or is there another area of the project you'd like to explore next?

--------------------------
Application Overview
This Flask-based application is a versatile tool for image and video processing, particularly geared towards creating, manipulating, and blending images for various creative projects. The application supports multiple functionalities, including image uploads, grayscale and binary mask generation, image blending, and video frame extraction. It's designed to provide a smooth user experience for managing and processing media files within a structured web interface.

Key Features
Image Uploading and Storage:

Users can upload images in various formats (PNG, JPG, JPEG, GIF) through a user-friendly web interface.
Uploaded images are securely stored in designated directories (static/archived-images), ensuring easy access and management.
Uploaded images are automatically organized by upload time, with the most recent images displayed first.
Mask Generation:

The application allows users to create masks for images using two different methods:
Grayscale Masking: Converts an image to grayscale and uses it as a mask for blending purposes.
Binary Masking: Converts an image to a binary format by calculating the mean pixel value and using it as a threshold. The resulting binary mask can be inverted for alternative effects.
These masks are saved in the static/archived-masks directory and can be applied to other images within the application.
Image Blending:

Users can blend two images using a selected mask (either grayscale or binary) with adjustable opacity settings.
The blending process is performed using the Pillow library, and the final blended image is saved in the static/archived-store directory.
The application ensures that the dimensions of all images involved in blending are consistent by resizing them to a standard size (512x768 pixels).
Video Frame Extraction:

The application can extract random frames from a video file, enabling users to generate a series of images from their video content.
Extracted frames are saved in the static/archived-images directory for further manipulation or use in blending processes.
Image Selection and Mask Application:

Users can select images for further processing, such as applying masks or blending with other images.
The application supports a selection workflow that allows users to preview and choose their desired images and masks through an intuitive web interface.
Logging and Debugging:

The application is equipped with a robust logging system that tracks actions and errors throughout the execution. Logs are saved to a file (exp_log.txt), providing detailed insights into the application’s behavior for debugging and monitoring purposes.
Subprocess Integration:

Certain features, like refreshing images or videos, are handled by external Python scripts. These scripts are executed through subprocess calls, allowing the application to manage complex tasks without blocking the main process.
This modular approach ensures that the application remains responsive and can handle additional processing in the background.
Web Interface and Routing:

The application provides a clean and organized web interface, allowing users to navigate between different functionalities, such as uploading files, selecting images, creating masks, and viewing results.
All major actions are linked to specific routes (/upload, /blend_images, /get_video_images, etc.), making the application easy to extend and maintain.
Use Cases
Creative Projects: Ideal for artists and designers who want to experiment with image blending and masking techniques to create unique visual compositions.
Video Processing: Useful for content creators who need to extract and manipulate frames from their video files for promotional materials or other purposes.
Web-Based Media Management: Provides a centralized platform for managing, processing, and storing images and videos in a structured and organized manner.
Conclusion
This application serves as a comprehensive toolkit for image and video processing, blending artistic creativity with technical precision. Whether you are working on a digital art project, creating promotional content, or simply experimenting with visual effects, this application offers the tools and flexibility you need to bring your ideas to life. With its user-friendly interface, versatile functionalities, and robust backend processing, the application empowers users to explore new possibilities in image manipulation and content creation.



<!DOCTYPE html>
<html>

<head>
    <title>Image Outline</title>

    <style>
        body {
            background-color: gray;
           
            color: white;
            font-family: Arial, sans-serif;
        }

        .refresh-button {
            display: inline-block;
            padding: 10px 20px;
            margin: 10px;
            font-size: 2em;
            background-color: orange;
            color: black;
            text-decoration: none;
            border-radius: 5px;
        }

        .refresh-button2 {
            display: inline-block;
            padding: 10px 20px;
            margin: 10px;
            font-size: 2em;
            background-color: yellow;
            color: black;
            text-decoration: none;
            border-radius: 5px;
        }

        .refresh-button:hover {
            background-color: #FFA500;
        }

        .image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }

        .image-container img {
            width: 60%;
            height: auto;
            border: 2px solid orange;
        }
    </style>
</head>

<body>
    <center>
        <h1 style="color: orange;">FlaskArchitect's Image Outline</h1>
        <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>
        <a href="{{ url_for('outlinefile') }}" class="refresh-button2">Outline Another</a><br>

        <div class="image-container">
            <!-- Display the temporary outline image -->
            <div>
                <h2 style="color: yellow;">Temporary Outline</h2>
                <img src="{{ url_for('static', filename=temp_filename.split('static/')[-1]) }}" alt="Temporary Outline">
            </div><br/>

            <!-- static/outlines/transparent_outline.png static/outlines/temp2.png static/outlines/outlined.png
            Display the final outlined image -->
            <div>
                <h2 style="color: yellow;">Transpart Outline</h2>
                <img src="static/outlines/transparent_outline.png" alt="Final Outlined Image">
            </div><br/>
            <div>
                <h2 style="color: yellow;">Final Outlined Image</h2>
                <img src="static/outlines/outlined.png" alt="Final Outlined Image">
            </div>
        </div>
    </center>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play MP3</title>
</head>
<body>
    <h1>Audio Player</h1>
    <audio controls>
        <source src="{{ url_for('static', filename=music.split('static/')[1]) }}" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>
</body>
</html>
<!-- post.html 
{% extends 'base.html' %}

{% block title %}{{ post[1] }} - My Blog{% endblock %}

{% block content %}
    <article>
        <h1>{{ post[1] }}</h1>
        <div><pre>{{ post[2] }}</pre></div>
        {% if post[3] %}
            <img src="data:image/png;base64,{{ post[3] }}" alt="{{ post[1] }}" style="max-width: 400px;">
        {% endif %}
    </article>
{% endblock %}
------------- -->
<!-- post.html -->
{% extends 'base.html' %}

{% block title %}{{ post[1] }} - My Blog{% endblock %}

{% block content %}
    <article>
        <h1>{{ post[1] }}</h1>
        <div><pre>{{ post[2] }}</pre></div>
        {% if post[3] %}
            <img src="data:image/png;base64,{{ post[3] }}" alt="{{ post[1] }}">
        {% endif %}
        {% if post[4] %}
            <video width="320" height="240" controls>
                <source src="{{ url_for('static', filename='videos/' + post[4]) }}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        {% endif %}
    </article>

    <form method="post" enctype="multipart/form-data" action="{{ url_for('upload_video', post_id=post[0]) }}">
        <div class="mb-3">
            <label for="videoFile" class="form-label">Upload Video:</label>
            <input type="file" class="form-control" id="videoFile" name="videoFile" accept="video/mp4">
        </div>
        <button type="submit" class="btn btn-primary">Submit</button>
    </form>
{% endblock %}

<!-- post.html -->
{% extends 'base.html' %}
{% block title %}{{ post[1] }} - My Blog{% endblock %}
{% block content %}
<article>
    <span>ID: {{ post[0] }} &nbsp;&nbsp; | &nbsp;&nbsp; {{ post[1] }}</span> &nbsp;&nbsp; | &nbsp;&nbsp;
    <a href="{{ url_for('edit_post', post_id=post[0]) }}">EDIT</a>
    <div><pre>{{ post[2] }}</pre></div>
    {% if post[3] %}
    <img src="data:image/png;base64,{{ post[3] }}" alt="{{ post[1] }}" />
    {% endif %}
    {% if post[4] %}
    <video width="320" height="240" controls>
        <source src="{{ url_for('static', filename='videos/' + post[4]) }}" type="video/mp4" />
        Your browser does not support the video tag.
    </video>
    {% endif %}
</article>

<form method="post" enctype="multipart/form-data" action="{{ url_for('upload_video', post_id=post[0]) }}">
    <div class="mb-3">
        <label for="videoFile" class="form-label">Upload Video:</label>
        <input type="file" class="form-control" id="videoFile" name="videoFile" accept="video/mp4" />
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>
{% endblock %}
<!--  post.html      -->
{% extends 'base.html' %}

{% block title %}{{ post[1] }} - My Blog{% endblock %}

{% block content %}
    <article>
        <h1>{{ post[1] }}</h1>
        <div><pre>{{ post[2] }}</pre></div>
        {% if post[3] %}
            <img src="data:image/png;base64,{{ post[3] }}" alt="{{ post[1] }}">
        {% endif %}
    </article>
{% endblock %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rorschach Inkblot Test</title>
    <style>
        body {
            background-color: #222;
            color: #ddd;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .inkblot-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .inkblot-container img {
            margin: 10px;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            width: 256px; /* or adjust according to your need */
            height: 384px; /* or adjust according to your need */
        }
    </style>
</head>
<body>
    <h1>Rorschach Inkblot Test</h1>
    <p>What do you see in the inkblots below?</p>
    <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>
    <div class="inkblot-container">
        {% for image in inkblot_images %}
            <img src="{{ url_for('static', filename=image.split('static/')[1]) }}" alt="Inkblot">
        {% endfor %}
    </div>
</body>
</html>
<!-- search.html -->
{% extends 'base.html' %}

{% block title %}Search Results - My Blog{% endblock %}

{% block content %}
<h1>Search</h1>
<form action="{{ url_for('searchfile') }}" method="post">
    <label for="search_terms">Search for (comma-separated):</label>
    <input type="text" id="search_terms" name="search_terms" required>
    <button type="submit">Search</button>
</form>

{% if results %}
<h2>Search Results</h2>
<ul>
    {% for result in results %}
    <li>
        <h3>{{ result[1] }}</h3>
        <p>{{ result[2][:200] }}...</p>
        {% if result[3] %}
        <img src="data:image/png;base64,{{ result[3] }}" alt="image.jpg">
        {% endif %}
        {% if result[4] %}
        <video width="320" height="240" controls>
            <source src="{{ url_for('static', filename='videos/' + result[4]) }}" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        {% endif %}
        <a href="{{ url_for('show_post', post_id=result[0]) }}">Read more</a>
    </li>
    {% endfor %}
</ul>
{% else %}


            <h1>Search Results for "{{ search_term }}"</h1>
            {% for item in data %}
                <div style="border-bottom: 1px solid #ccc; padding: 10px;">
                    <pre>{{ item }}</pre>
                </div>
            {% endfor %}
            <a href="/search_file">Search Again</a>
<p>No results found</p>
{% endif %}

{% endblock %}
<!-- search.html -->
{% extends 'base.html' %}

{% block title %}Search Results - My Blog{% endblock %}

{% block content %}
<h1>Search</h1>
<form action="{{ url_for('search') }}" method="post">
    <label for="search_terms">Search for (comma-separated):</label>
    <input type="text" id="search_terms" name="search_terms" required>
    <button type="submit">Search</button>
</form>

{% if results %}
<h2>Search Results</h2>
<ul>
    {% for result in results %}
    <li>
        <h3>{{ result[1] }}</h3>
        <p>{{ result[2][:200] }}...</p>
        {% if result[3] %}
        <img src="data:image/png;base64,{{ result[3] }}" alt="image.jpg">
        {% endif %}
        {% if result[4] %}
        <video width="320" height="240" controls>
            <source src="{{ url_for('static', filename='videos/' + result[4]) }}" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        {% endif %}
        <a href="{{ url_for('show_post', post_id=result[0]) }}">Read more</a>
    </li>
    {% endfor %}
</ul>
{% else %}
<p>No results found</p>
{% endif %}

{% endblock %}
<!DOCTYPE html>
<html>

<head>
    <title>Search Results</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />

    <script>
        // Function to find and highlight the search string
        function findString(str) {
            if (parseInt(navigator.appVersion) < 4) return;

            // Check if find method is supported
            if (window.find) {
                // Find the search string
                var strFound = window.find(str);
                if (!strFound) {
                    // If not found, try to find from the beginning
                    window.find(str, 0, 1);
                }
                if (strFound) {
                    // Highlight the found text
                    var range = window.getSelection().getRangeAt(0);
                    var span = document.createElement("span");
                    span.style.backgroundColor = "yellow";
                    range.surroundContents(span);
                }
            } else if (navigator.appName.indexOf("Microsoft") != -1) {
                // Handle Microsoft browsers
                // Not implemented for brevity
            } else if (navigator.appName == "Opera") {
                // Handle Opera browsers
                alert("Opera browsers not supported, sorry...");
                return;
            }

            // If not found, show alert
            if (!strFound) alert("String '" + str + "' not found!");
        }

        // Function to move cursor to next occurrence of search input
        function moveToNextOccurrence() {
            var search_str = document.getElementById("search_input").value;
            findString(search_str);
        }
    </script>
</head>

<body>
    <header class="sticky">
    <span>Search Results</span>&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;
    <input type="text" id="search_input" />

    <button id="search_submit" onclick="moveToNextOccurrence()">
        Find in page Next</button>&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;

    <a class="note" href="{{ url_for('home') }}">Back to Home</a>
    </header>
    <div class="posts">
        {% if results %} {% for post in results %}
        <div class="post">
            <h2>{{ post.title }}</h2>
            <pre>{{ post.content[:400] }}...</pre>
            <a href="{{ url_for('post', post_id=post.id) }}">Read more</a>
            <a href="{{ url_for('edit_post', post_id=post.id) }}">Edit</a>
        </div>
        {% endfor %} {% else %}
        <p>No results found for search terms: {{ search_terms | join(", ") }}</p>
        {% endif %}
    </div>
    <a href="{{ url_for('home') }}">Back to Home</a>
</body>

</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Processing with Flask</title>
</head>
<body>
    <h1>Upload Mask Image and Set Parameters</h1>
  <!doctype html>
    <title>Upload an image</title>
    <h1>Upload an image for segmentation processing</h1>
    <form method=post enctype=multipart/form-data>
      <input type=file name=file>
      <input type=submit value=Upload>
    </form>
    '''
        <h2>Uploaded Image: {{filename}}</h2>

        <img src="static/archived-images/processed.png" alt="Processed Image">

</body>
</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Select Images for Blending</title>
    <style>
        body {
            background-color: cadetblue;


        }

        h1 {
            color: orange;
            margin: 0px auto;
            text-align: center;
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            padding: 20px;
        }

        .image-item {
            margin: 10px;
            text-align: center;
        }

        .image-item img {
            width: 256pxs;
            height: 384px;
           
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .image-item label {
            display: block;
            margin-top: 5px;
        }

        button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }
        .sticky {
            position: -webkit-sticky;
            position: sticky;
            color: #ffa600;
            width: 85%;
            top: 0;
            margin-left: auto;
            margin-right: auto;
            
            text-align: center;
            background-color: #af0909;
            padding: 10px 0;
            z-index: 1000;
        }
        a {
            color: #ffa600;
            font-size: 20px;
        
        }
   
    </style>
</head>

<body>
    <h1 id="top">Select Images for Blending</h1>
    <p class="sticky"><a href="#jump">Submit/Page Bottom</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="{{ url_for('index') }}">Home</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    
    </p><form action="{{ url_for('blend_images') }}" method="post">
        <div class="container">
            {% for image_path in image_paths %}
            <div class="image-item">
                <img src="{{ image_path }}" alt="Image">
                <div>
                    <label>
                        <input type="radio" name="top_image" value="{{ image_path }}" required> Top
                    </label>
                    <label>
                        <input type="radio" name="mask_image" value="{{ image_path }}" required> Mask
                    </label>
                    <label>
                        <input type="radio" name="bottom_image" value="{{ image_path }}" required> Bottom
                    </label>
                </div>
            </div>
            {% endfor %}
        </div>

        <label for="opacity">Opacity (between 0 and 1):</label>
        <input type="text" id="opacity" name="opacity" value="0.5">
        <button id="jump" type="submit">Submit</button>
    </form>&nbsp;&nbsp;
    <a style="color:navy;margin-left: auto;margin-right: auto;" href="#top">Page Top</a>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Select Mask Image</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #c7c7c7;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .image-item {
            flex: 1 1 calc(20% - 10px);
            box-sizing: border-box;
            margin-bottom: 10px;
            text-align: center;
        }
        .image-item img {
            max-width: 205px;
            
            height: auto;
            display: block;
            border: 2px solid #444;
            border-radius: 5px;
            transition: transform 0.2s;
        }
        .image-item img:hover {
            transform: scale(1.05);
        }
        .image-item input[type="radio"] {
            display: none;
        }
        .image-item label {
            display: block;
            cursor: pointer;
        }
        .image-item input[type="radio"]:checked + label img {
            border-color: #007bff;
        }
        .form-container {
            text-align: center;
            margin-top: 20px;
        }
        .form-container button {
            background-color: #007bff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .form-container button:hover {
            background-color: #0056b3;
        }
        img {
            width: 200px;
            height: auto;
        }
    
    </style>
</head>
<body>
    <h1>Select an Image for Masking</h1>
    <form action="{{ url_for('select_mask_image') }}" method="post">
        <div class="image-container">
            {% for image_path in image_paths %}
                <div class="image-item">
                    <input type="radio" name="selected_image" id="{{ image_path }}" value="{{ image_path }}">
                    <label for="{{ image_path }}">
                        <img src="{{ url_for('static', filename=image_path.split('static/')[-1]) }}" alt="Image">
                    </label>
                </div>
            {% endfor %}
        </div>
        <div class="form-container">
            <button type="submit">Select Image</button>
        </div>
    </form>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torn Edge Effect</title>
    <style>
        .image-container {
            display: flex;
            justify-content: space-around;
            margin: 20px;
        }
        .image-container img {
            max-width: 45%;
            height: auto;
        }
    </style>
</head>
<body style="background-color: cadetblue;">
    <center>
    <h1 style="color: orange;">FlaskArchitect's Torn EdgeEffect</h1>
    <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    <div class="image-container">
        <div>
            <h2>Original Image</h2>
            <img src="{{ url_for('static', filename=original_image) }}" alt="Original Image">
        </div>
        <div>
            <h2>Torn Edge Image</h2>
            <img src="{{ url_for('static', filename=torn_image) }}" alt="Torn Edge Image">
        </div>
    </div>
    </center>       
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torn Edge Effect</title>
    <style>
        .image-container {
            display: flex;
            justify-content: space-around;
            margin: 20px;
        }
        .image-container img {
            max-width: 45%;
            height: auto;
        }
    </style>
</head>
<body style="background-color: cadetblue;">
    <center>
    <h1 style="color: orange;">FlaskArchitect's Torn EdgeEffect</h1>
    <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    <div class="image-container">
        <div>
            <h2>Original Image</h2>
            <img src="{{ url_for('static', filename=original_image) }}" alt="Original Image">
        </div>
        <div>
            <h2>Torn Edge Image</h2>
            <img src="{{ url_for('static', filename=torn_image) }}" alt="Torn Edge Image">
        </div>
    </div>
    </center>       
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torn Edge Effect</title>
    <style>
        .image-container {
            display: flex;
            justify-content: space-around;
            margin: 20px;
        }
        .image-container img {
            max-width: 45%;
            height: auto;
        }
    </style>
</head>
<body style="background-color: cadetblue;">
    <center>
        <h1 style="color: orange;">FlaskArchitect's Torn Edge Effect</h1>
        <a href="{{ url_for('index') }}" class="refresh-button">HOME</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        <div class="image-container">
            <div>
                <h2>Original Image</h2>
                <img src="{{ url_for('static', filename='archived-images/' + filename) }}" alt="Original Image">
            </div>
        </div>
    </center>       
</body>
</html>
<!-- upload_image.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Image</title>
</head>
<body>
    <h1>Upload Image</h1>
    <form action="/upload_image" method="POST" enctype="multipart/form-data">
        <label for="image">Choose an image to upload:</label>
        <input type="file" name="image" id="image" required>
        <button type="submit">Upload</button>
    </form>
</body>
</html>
<!DOCTYPE html>
<html>

<head>
    <title>Edit a Text File</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 1%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-image: url('../static/assets/01-back.jpg');
            background-repeat: repeat-y;
            background-size: cover;
            /* Use 'cover' to make the image cover the entire body */
            background-position: top;
        }

        .wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 10vh;
        }

        .header {
            width: 100%;
            padding: 20px;
            text-align: center;
        }
        #logo {
      position: absolute;
      /* Position the logo absolutely */
      top: 5vw;
      /* Adjust the top distance as needed */
      left: 2vw;
      /* Adjust the left distance as needed */
      max-width: 10vw;
      /* Set a maximum width for the logo */
      max-height: 15vw;
      /* Set a maximum height for the logo */
  }
    </style>
 
</head>

<body>
    <script>
        // Fetches the file content and updates the textarea
        function loadFileContent() {
            var select = document.getElementById("filename-select");
            var textarea = document.getElementById("file-content");
            var selectedFile = select.value;

            if (selectedFile) {
                fetch(`/get_file_content/${selectedFile}`)
                    .then(response => response.text())
                    .then(content => {
                        textarea.value = content;
                    })
                    .catch(error => {
                        console.error('Error fetching file content:', error);
                    });
            } else {
                textarea.value = "";
            }
        }

        // Call the function initially to load content for the selected file
        loadFileContent();
    </script>
    <div class="wrapper"><a href="{{ url_for('view_text') }}"><img id="logo" src="../static/assets/channels4_profile.png" alt="logo"/> </a><br/>

        <a href="{{ url_for('search_files') }}"><img id="logo" src="../static/assets/search.png" alt="logo"/> </a>

        <form method="POST" action="{{ url_for('new_snippet') }}">
            <label for="snippet_content">New Content:</label><br>
            <textarea id="snippet_content" name="content" rows="20" cols="100"></textarea><br>
            <input type="submit" value="Save">
        </form>
    </div>
</body>

</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View Log</title>
</head>
<body>
    <h1>View Log</h1>
    {% for line in data %}
    {{line}}<br/>
{% endfor %}




</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Extracted Images</title>
</head>
<body>
    <h1>Extracted Images</h1>
    <!-- link to home -->
     <a href="/">Index</a>
    <div>
        {% for image in images %}
            <img src="{{ image }}" alt="Extracted Frame" style="width: 256px; height:384px; margin: 10px;">
        {% endfor %}
    </div>
    <a href="/">Back</a>
</body>
</html>
